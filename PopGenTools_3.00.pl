#!/usr/bin/perl
#Dependencies: ANGSD (http://popgen.dk/wiki/index.php/ANGSD); ngsTools (https://github.com/mfumagalli/ngsTools); Your brain.
#ngsCovar, ngsFst, angsd, emOptim2, and sfstools in path.


## Author: Ke Bi (ke@berkeley.edu)
## Computational Genomics Resource Laboratory
## California Institute for Quantitative Biosciences
## University of California, Berkeley
## 238 Koshland Hall
## Berkeley, CA 94720-3102


use strict; 
use warnings;
use Getopt::Std;
use Getopt::Long;
use File::Basename;
use Math::Trig;
#use Geo::Proj4;
use List::Util qw[min max];
#use Statistics::R;

&main;
exit;

sub main {
        &usage if (@ARGV<1);
        my $command = shift(@ARGV);
        my %p = (Structure=>\&Structure, PCA=>\&PCA, ANGSD=>\&ANGSD, Adegenet=>\&Adegenet, Admixture=>\&Admixture, SNPID=>\&SNPID, SNP2D=>\&SNP2D, MERGE=>\&MERGE, SPA=>\&SPA, FST=>\&FST, Outgroup=>\&Outgroup, TREEMIX=>\&TREEMIX, DADI=>\&DADI, GEODIST=>\&GEODIST, BAYENV=>\&BAYENV, Geneland=>\&Geneland, GENEPOP=>\&GENEPOP, VCF2NEXUS=>\&VCF2NEXUS, VCF2smartPCA=>\&VCF2smartPCA,VCF2structure=>\&VCF2structure,VCF2admixture=>\&VCF2admixture,VCF2splittree=>\&VCF2splittree, VCF2SPA=>\&VCF2SPA, POPFilter=>\&POPFilter,NEXUS=>\&NEXUS,PLINK=>\&PLINK, CONTIG=>\&CONTIG, PHASE=>\&PHASE,Dxy=>\&Dxy, raxml=>\&raxml );
        die("Unknown command \"$command\"\n") if (!defined($p{$command}));
        &{$p{$command}};
      }

sub usage {
  die(qq/
Usage:  PopGenTools3.00.pl <command> [<arguments>]\n
Command: 

ANGSD: SNP calling, genotype calling and allel frequency 
       estimating using ANGSD, with or without an outgroup reference

PCA:   Use ngsCovar to generate genetic covariance matrix
       from genotype output by ANGSD -doGeno 32

FST:   Calculate Fst using ngsFST

NEXUS: Convert genotypes (ANGSD -doGeno 2) to nexus format

GENEPOP: Convert genotypes (ANGSD -doGeno 4) to GENEPOP input

Structure:  Convert genotypes (ANGSD -doGeno 4) to STRUCTURE input

Adegenet: Convert genotypes (ANGSD -doGeno 2) to adegenet input to calculate genetic distance

Admixture: Convert genotypes (ANGSD -doGeno 2) to ADMIXTURE input

SPA: Covert genotypes (ANGSD -doGeno 2) to SPA input

TREEMIX:  Covert genotypes (ANGSD -doGeno 2) to Treemix input

POPFilter: Perform filtering on missing data for each sub population, require (ANGSD -doGeno 2)

PINK: prune SNPs for LD

SNPID: Identify SNP ID based on *.prob (ANGSD sfstools) and *.sfs.pos (ANGSD angsd) 

SNP2D: Identify specific SNPs from 2dSFS based on *.prob (ANGSD sfstools) and *.sfs.pos (ANGSD angsd)

MERGE: merge .pos files to generate concensus .keep file for second round ANGSD

GEODIST: convert geographic coordinates to geographic distances

Geneland: Covert genotypes (ANGSD -doGeno 2) to Geneland input and covert lat and long to UTM

BAYENV: Covert genotypes (ANGSD -doGeno 2) to BAYENV input file

CONTIG: reconstruct sequence alignment based on SNPs

PHASE: convert genotype (-doGeno 2) to PHASE input file and perform PHASE analyses

Dxy: calculate Dxy using ANGSD genotype (-doGeno 2)

Outgroup: parse VCF file and make outgroup fasta

VCF2NEXUS: call SNPs from vcf then convert it to nexus format for Beauti and SNAPP

VCF2smartPCA: call SNPs from vcf then generate input files for smartPCA

VCF2structure: call SNPs from vcf then generate input files for STRUCTURE

VCF2admixture: call SNPs from vcf then generate input files for admixture

VCF2splittree:  call SNPs from vcf then generate input files for splitree

VCF2SPA: call SNPs from vcf then generate input files for SPA

raxml: generating raxml input files from the alignment (bams)

\n/);
}

####################################################################################################################################################


sub Outgroup {
  die(qq/
Usage PopGenomics.pl Outgroup [options]

Options: -v FILE VCF: generated by outgroup reads mapped to ingroup fasta sequences; i.e. samtools mpileup -D -S -I -B -f ingroup.fa bam1 bam2 bam3... | bcftools view - cg-> raw.vcf 
         -f FILE re-constructed fasta file by vcfutils.pl vcf2fq in SamTools i.e. mpileup -uf ref.fa -l filtered.bed aln.bam | bcftools view -cg - | vcfutils.pl vcf2fq > cns.fq; Note "filtered.bed" is generated by using SNPcleaner.pl by Tyler Linderoth. 
         -c FILE  original in-group reference used to align reads from outgroup libraires. 
         -o FILE outfile name
\n/) if (!@ARGV);
  
  my %opts = (v=>undef, f=>undef, c=>undef, o=>undef);
  getopts('v:f:c:o:', \%opts);
  
  
  
  my $VCF = $opts{v}  or die ("\nError! You must provide the name of VCF file!\n\n")  ;
  my $raw_ref = $opts{f} or die ("\nError! Cannot open the re-constructed fasta file!\n\n");
  my $outfile = $opts{o} or die ("\nError! You must define the name of outfile!\n\n") ;
  my $orig_ref = $opts{c} or die ("\nError! Original in-group reference used to align reads from outgroup libraires is not provided! \n\n") ;
  
  
  my $file;
  open($file, $raw_ref); 
  my %sequence_data; 
  my $new_raw_ref = 'new_raw.fa';
  open (OUT, '>', $new_raw_ref);
  
  
  my $start0 = time;
  while (read_fasta($file, \%sequence_data)) {
    print OUT ">$sequence_data{header}\n$sequence_data{seq}\n";
  }
  close OUT;
  my $time0 = int(time - $start0);
  print "Re-formatted fasta sequences $time0 sec!\n";
  
  my $start1 = time;
  my $fixed = 'new_raw_fixed.fa'; 
  mask($new_raw_ref, $VCF, $fixed);
  final($fixed, $orig_ref, $outfile);
  my $time1 = int(time - $start1);
  print "Made outgroup reference $time1 sec! Hew! It has taken so long!\n";
  
  sub read_fasta {
    my ($file,$seqio) = @_;
    
    $seqio->{seq} = undef; 
    
   
    $seqio->{header} = $seqio->{next_header} if $seqio->{next_header};
    
    my $file_not_empty = 0; 
    while (<$file>) {
      $file_not_empty = 1;
      next if /^\s*$/; 
      chomp;    
      
      if (/^>/) { 
	my $header = $_;    
	$header =~ s/^>//;  
	if ($seqio->{header}) {
	  $seqio->{next_header} = $header;
	  return $seqio;   
	}              
	else { 
	  $seqio->{header} = $header;
	}              
      }         
      else {    
	s/\s+//;  
	$seqio->{seq} .= $_;
      }         
    }    
    
    if ($file_not_empty) {
      return $seqio;
    }    
    else {
      $seqio->{header} = $seqio->{seq} = $seqio->{next_header} = undef;      
      return;   
    }    
  }
  
  
  sub mask{
    my ($new_raw_ref, $VCF, $fixed) = @_;
    open (IN1, '<', $new_raw_ref);
    open (IN2, '<', $VCF);
    open (OUT, '>', $fixed);
    my %data;
    while (<IN1>) {
      chomp (my $line = $_);
      if ($line  =~ m /^>/ ) {
	chomp($data{$line} = <IN1>); 
      }
    }
    close IN1;
    
    while (<IN2>) {
      chomp (my @line = split /\t/, $_);
      if ($line[0] =~ m/^Contig/) {
	my $alt = $line[4];
	my $pos = $line[1];
	my $contig = '>'. $line[0];
	my @alt = split /,/, $alt;
	if (scalar (@alt) > 1 ) {
	  if  ( length($data{$contig})) {
	    if ( length($data{$contig}) >= $pos) {
	      substr ($data{$contig}, $pos-1, 1) ='B';
	    }
	  }
	}
      }
    }
    close IN;
    
    my %newdata;
    foreach (keys(%data)) {
      $data{$_} =~ s/[a|c|g|t|n|y|s|k|r|w|m|B|Y|S|R|K|W|M]/N/g ; 
      $newdata {substr($_, 7)} = $data{$_};
    } 
    for my $key (sort {$a<=>$b} keys %newdata) {
      print OUT '>Contig'.$key, "\n", $newdata{$key},"\n";
    } 
    close OUT;
    unlink ($new_raw_ref);
  }
  
  sub final {
    my ($fixed, $original, $final) = @_;
    
    open (IN1, "<", $original);
    open (IN2, "<", $fixed);
    open (OUT,">", $final);
    
    my %ori;
    my %fix;
    while (<IN1>) {
      chomp (my $line = $_);
      if ($line  =~ m /^>/ ) {
	chomp($ori{$line} = <IN1>); 
      }
    }
    close IN1;
    
    while (<IN2>) {
      chomp (my $line = $_);
      if ($line  =~ m /^>/ ) {
	chomp ($fix{$line} = <IN2>); 
      }
    }
    close IN2;
    
    my %newfix;
    foreach my $line (keys %ori) {
      if ($fix{$line}) {
	if ((length ($fix{$line})) < (length ($ori{$line}))) {
	  
	  my $diff = (length ($ori{$line})) - (length ($fix{$line})); 
	  my $N = 'N' x $diff;
	  #print $line, "\n";
	  #print length ($fix{$line}), "\t", length ($ori{$line}), "\n";
	  my $newseq =  $fix{$line}. $N; 
	  #print $newseq, "\n";
	  $newfix {substr($line, 7)} = $newseq; 
	}
	elsif ((length ($fix{$line})) > (length ($ori{$line}))) {
	}
	else {
	  $newfix {substr($line, 7)} = $fix{$line};	  	  
	}
      }
      else  {
	$newfix{substr($line, 7)} = 'N' x length($ori{$line});
      }      
    }
    
    for my $key (sort {$a<=>$b} keys %newfix) {
      print OUT '>Contig'.$key, "\n", $newfix{$key},"\n";      
    } 
    close OUT; 
    unlink ($fixed);
  }
  
}





####################################################################################################################################################

sub MERGE {
  die(qq/
Usage PopGenomics.pl MERGE [options]

Options: -a FILE .pos of population 1
         -b FILE .pos of population 2
         -c INT  if 1 generate concensus, private SNPs are removed; if 2 combine two pos files including private and shared SNPs [2]
         -o FILE outfile name
\n/) if (!@ARGV);
   
  my %opts = (a=>undef, b=>undef, c=>2, o=>undef);
  getopts('a:b:c:o:', \%opts);
  
  open (IN1, "<", $opts{a})  or die ("\nError! .pos of population 1 is missing!\n\n") ;
  open (IN2, "<", $opts{b}) or die ("\nError! .pos of population 2 is missing!\n\n") ;
  open (OUT,">", $opts{o}) or die ("\nError! Must define the outfile!\n\n") ;
  
  if ($opts{c} == 1) {
    my %mod;
    
    while (<IN1>) {
      chomp (my @line = split /\t/, $_);
      $mod{$line[0]}{$line[1]} = 1;
    }
    close IN1;
    
    my %hist;
    while (<IN2>) {
      chomp (my @line2 = split /\t/, $_);
      $hist{$line2[0]}{$line2[1]} = 1;
    }
    close IN2;
    
    my %new;
    
    foreach my $contig (sort {$a <=> $b} keys %hist){
      foreach my $pos (sort {$a <=> $b} keys %{$hist{$contig}}) {
	
	if ($mod{$contig}{$pos}) {
	  print OUT $contig, "\t",  $pos, "\n";
      }
      
    }
     
  }
   close OUT;  
  }
  if ($opts{c} == 2) {
    system ("cat $opts{a} $opts{b} > merge");
    open (IN1, "<", 'merge');
    open (OUT,">", $opts{o});
    
    my %mod;
    
    while (<IN1>) {
      chomp (my @line = split /\t/, $_);
      $mod{$line[0]}{$line[1]} = 1;
    }
    close IN1;
    
    my %new;    
    foreach my $contig (sort {$a <=> $b} keys %mod){
      foreach my $pos (sort {$a <=> $b} keys %{$mod{$contig}}) {	  
	print OUT $contig, "\t", $pos, "\n";
      }
      
    }    
   close OUT;
    system ("rm merge");
  }
}    


####################################################################################################################################################


sub Structure {
  die(qq/
Usage PopGenomics.pl Structure [options]

Options: -g FILE raw genotype probability generated using ANGSD "-doGeno 4" (e.g. Contig29 294 TT TT TA....)
         -n INT  sample size
         -s INT  number of loci
         -o FILE outfile name
         -h FILE Population information
         -p      if p is supplied, Random choose one SNP per contig.
\n/) if (!@ARGV);
  
  my %opts = (g=>undef, n=>undef, s=>undef,o=>undef,h=>undef);
  getopts('n:g:s:o:h:p', \%opts);
  my %genos = ('AA' => 0 , 'AC' => 1, 'CA'=>1, 'AG' => 2, 'GA' => 2,  'AT' => 3, 'TA'=>3, 'CC'=> 4, 'CG'=>5, 'GC'=>5, 'CT' => 6, 'TC' => 6, 'GG'=>7, 'GT'=>8, 'TG'=>8, 'TT'=>9, 'NN' => -9);
  # A = 1, C = 2, G = 3, T = 4
  my %genos2 = ('0' => ['1','1'], '1' => ['1','2'], '2' => ['1','3'], '3' => ['1','4'], '4'=>['2','2'], '5'=>['2','3'], '6' => ['2','4'], '7'=>['3','3'], '8'=>['3','4'], '9'=>['4','4'], '-9' => ['-9','-9'] );
  
  
  unless ($opts{p}) {
    my $start0 = time;
    my $out = 'cleaned';
    trim($opts{n},$opts{s},$opts{g},$out,\%genos);
    my $time0 = int(time - $start0);
    print "Xixi...Trimmed original genotype matrix in $time0 sec!\n";
    
    my $start1 = time;
    my $out2= 'converted2';
    transpose($out, $opts{n}, $opts{s}, $out2); #transpose the matrix;
    my $time1 = int(time - $start1);
    print "Hehe...Transposed cleaned genotype matrix in $time1 sec! \n";
    
    my $start2 = time;
    my $final = $opts{o};
    convert($out2, $final, \%genos2); #convert the transposed matrix to input for STRUCTURE;
    my $time2 = int(time - $start2);
    print "Hoho... Converted transposed genotype matrix to STRUCTURE input in $time1 sec!\n";
  }
  
  
  if ($opts{p}) {
    open (IN, "<", $opts{g}); 
    my %hash;
    my %hash1;    
    my $size = $opts{n};
    open (OUT, ">", "selected");  
    
    
    foreach (<IN>) {
      chomp (my @line = split /\s/, $_);
      my $site = 0;
      my $missing = 0;
      my $hets = 0;
      my @geno;
      foreach my $m (@line[2..$#line]) {
	if ($m ne 'NN') {
	  push (@geno, $genos{$m});
	  $site++;	 
	}
	if ($m eq 'NN') {
	  $site++; $missing++;
	}
	if ($m ne 'AA' && $m ne 'TT' & $m ne 'CC' && $m ne 'GG' && $m ne 'NN' ) {
	  $hets++;
	}   
      }
      
      my %seen;
      my @unique = grep { ! $seen{$_}++ } @geno;
      if ($hets > 0 ) {
	if (scalar @unique <=3 && scalar @unique >= 2 && $site == $size && $missing/$site < 0.2) {
	  $hash{$line[0]}{$line[1]} = join ("\t",@line[2..$#line] ); 	
	}
      }      
      if ($hets == 0) {
	if ( scalar @unique == 2 && $site == $size && $missing/$site < 0.2) {
	  $hash{$line[0]}{$line[1]} = join ("\t",@line[2..$#line] ); 	
	}
      }   
	
    } 
    close IN;
    
    foreach (sort {$a cmp $b} keys %hash) { 
      my @array = ();
      foreach my $pos (keys %{$hash{$_}}){
	push (@array, $pos);
       }
      my $randomelement = $array[rand @array];
      print OUT $_, "\t", $randomelement, "\t", join("\t",$hash{$_}{$randomelement}), "\n";
      print $_, "\t", $randomelement, "\t", join("\t",$hash{$_}{$randomelement}), "\n";
    } 
    close OUT;
    
    
    open (IN2, "<", "selected");
    my $n = 0;
    foreach (<IN2>) {
      chomp(my @line = split /\t/, $_);
      $n++;   
    }
    close IN2;
    print "The number of selected sites now is: ", $n, "\n";
 
    
    my $start0 = time;
    my $out = 'cleaned';
    trim($opts{n},$opts{s},"selected",$out,\%genos);
    my $time0 = int(time - $start0);
    print "Xixi...Trimmed original genotype matrix in $time0 sec!\n";
    
    
    
    my $start1 = time;
    my $out2= 'converted';
    transpose($out, $opts{n}, $n, $out2); #transpose the matrix;
    my $time1 = int(time - $start1);
    print "Hehe...Transposed cleaned genotype matrix in $time1 sec! \n";
    
    my $start2 = time;
    my $final = $opts{o};
    convert($out2, $final, \%genos2, $opts{h}); #convert the transposed matrix to input for STRUCTURE;
    my $time2 = int(time - $start2);
    print "Hoho... Converted transposed genotype matrix to STRUCTURE input in $time1 sec!\n";
    
    
  }
  
  
  sub trim{
    my ($sample, $sites, $file, $out, $genos) = @_;
    my %genos = %{$genos};
    open (GENOPROB, '<', $file); 
    open (OUT, '>', $out);
    foreach (<GENOPROB>) {
      my @geno = split /\s+/, $_; 
      for (my $i = 2; $i<=$sample ;$i++) {
	print OUT $genos{$geno[$i]}, "\t";
      }
      print OUT $genos{$geno[$sample+1]},"\n";
    }
    close GENOPROB;
    close OUT;
    #unlink ($file);
  }
  
  sub transpose {
    my ($file, $size, $site1, $out) = @_;
    open (OUT1, '>', $out);  
    for (my $i = 1; $i <= $size; $i++) {
      my $count = $site1;
      open (IN1, '<', $file);
      foreach (<IN1>) {
	chomp();	  
	if ($count > 1) {
	  my @line = split /\s+/, $_;
	  print OUT1 $line[$i-1], "\t";
	  $count--;
	}
	elsif ($count == 1) {
	  my @line = split /\s+/, $_;
	  print OUT1 $line[$i-1], "\n";
	}
	else {
	  last;
	}
      }
    }
    close IN1;
    close OUT1;
   # unlink ($file);
  }
  
  sub convert {
    my ($file, $final, $genos2,$pop) = @_;
    my %genos2 = %{$genos2};
    open (IN, '<', $file);
    open (OUT,'>', $final);

    open (POP, '<',$pop);
    my $d = 1;
    my %pop;
    foreach (<POP>) {
    chomp(my @line = split /\t/, $_);
    $pop{$d} = $line[1];
    $d++;
    }
    my $i = 1;
    foreach (<IN>) {
      my @array1;
      my @array2;
      
      chomp (my @line = split /\s+/, $_);

      foreach my $gene (@line) {
	push (@array1, "\t", $genos2{$gene}[0]);
      }
      print OUT $i, "\t", $pop{$i}, @array1, "\n";
      foreach my $gene2 (@line) {
	push (@array2, "\t",$genos2{$gene2}[1]);
      } 
      print OUT $i,"\t", $pop{$i}, @array2, "\n";
      $i++;
    }
    unlink ($file);
    
  }
  close OUT;
  close IN;
  
}

####################################################################################################################################################


sub Admixture {
  die(qq/
Usage PopGenomics.pl Admixture [options]

Options: -g FILE raw genotype probability generated using ANGSD "-doGeno 2" (e.g. Contig29 294 0 1 2 -1 -1 2 1....)
         -o FILE outfile perfix
         -p      Randomly selects one snp per contig, kick off non-varibale sites
         -n INT  sample size (need -p)

\n/) if (!@ARGV);
  
  
  my %opts = (g=>undef,o=>undef, n=>undef);
  getopts('g:o:n:p', \%opts);
  
  unless ($opts{p}) {    
    system ("sed 's/-1/9/g' $opts{g} > $opts{o}_converted");
    open (IN, "<", $opts{o}. "_converted");
    open (OUT, ">", $opts{o} . "_admixture.geno");
    system ("rm $opts{o}_converted");
    while (<IN>) {
      chomp (my @line = split /\s+/, $_);
      my $add = 0;
      my $site = 0;
      my $missing = 0;
      foreach my $m (@line[2..$#line]) {
	if ($m eq '2' || $m eq '1') {
	  $add++; $site++; 	 
	}
	if ($m eq '0') {
	  $site++;
	} 
	if ($m eq '9') {
	  $site++;$missing++;
	}
      }
      if ($add > 0 && ($missing/$site <= 0.1)) {
	print OUT  @line[2..$#line],"\n"; 		
      }
    }
    close IN;
    close OUT;
  }
  
  
  

  
  if ($opts{p}) {
    system ("sed 's/-1/9/g' $opts{g} > $opts{o}_converted");
    open (IN, "<", $opts{o} . "_converted");
    my %hash;
    my $size = $opts{n};
    open (OUT, ">", $opts{o} . "_selected");
    
    
    foreach (<IN>) {
      chomp (my @line = split /\s/, $_);
      my $add = 0;
      my $site = 0;
      foreach my $m (@line[2..$#line]) {
       if ($m eq '2' || $m eq '1') {
	 $add++; $site++; 	 
       }
       if ($m eq '0') {
	 $site++;
       } 
       if ($m eq '9') {
	 $site++;
       }
       if ($add > 0 && $site == $size) {
	 $hash{$line[0]}{$line[1]} = join ("\t",@line[2..$#line] ); 	
	 
       }
     }
    } 
     close IN;
     
     foreach (sort {$a cmp $b} keys %hash) { 
       my @array = ();
       foreach my $pos (keys %{$hash{$_}}){
	 push (@array, $pos);
       }
       my $randomelement = $array[rand @array];
       print OUT $_, "\t", $randomelement, "\t", join("\t",$hash{$_}{$randomelement}), "\n";
     } 
    close OUT;
    
    open (OUT2, ">", $opts{o} . "_admixture.geno");
    open (IN2, "<", $opts{o} . "_selected");
      
      foreach (<IN2>) {
	chomp(my @line = split /\t/, $_);
	print OUT2 join('', @line[2..$#line]), "\n"; 
      }
    close IN2;
    close OUT2;
    system ("rm $opts{o}_selected $opts{o}_converted");
  }
}

###################################################################################################################################################


sub Adegenet {
  die(qq/
Usage PopGenomics.pl geno_to_adegenet [options]

Options: -g FILE raw genotype probability generated using ANGSD "-doGeno 2" (e.g. Contig29 294 0 1 2 -1 -1 2 1....)
         -n INT  sample size
         -s INT  number of loci
         -o FILE outfile name
         -h INT  1 = all sites; 0 = one snp per contig [1] ##only keep informative
         -p      Jason Bragg method for choosing SNPs: 1) Selects one snp per contig; 2) A SNP must have a genotype called in all samples; 3) It must be parsimony informative (minor allele present in > 1 sample) - note this has been modified below; 4) If multiple SNPs in a contig fulfil these criteria, one SNP is chosen at random. If -p is not used, all sites will be converted. 

Note: you can only choose either -h or -p

\n/) if (!@ARGV);
         
  
  my %opts = (g=>undef, n=>undef, s=>undef,o=>undef, h=>1);
  getopts('n:g:s:o:h:p', \%opts);
  my %geno_hash = ('-1' => ['N','A'], '0' => ['1','1'], '1' => ['1','2'], '2' => ['2','2']);
  
  
 unless ($opts{p}) {
    if ($opts{h} == 1 ) {
      open (IN, "<", $opts{g});
    my $out = 'trimmed';
    open (OUT,">", $out);
    foreach (<IN>) {
      chomp (my @line = split /\s+/, $_);
      my $add = 0;
      my $site = 0;
      my $missing = 0;
      my @new;
      foreach my $m (@line[2..$#line]) {
	if ($m eq '2' || $m eq '1') {
	  $add++; $site++; 
	}
	if ($m eq '0') {
	  $site++;
	} 
	if ($m eq '-1') {
	  $site++; $missing++;
	}
	my $gene = $geno_hash{$m}[0] . $geno_hash{$m}[1];
	push (@new,  $gene);
      }
      if ($add > 1 && ($missing/$site <= 0.2)) {	
	  print OUT join ("\t", @new),"\n"; 		
      }
    }
    close IN;
    close OUT;
    open (IN2,"<", $out);
    my $add;
    while (<IN2>) {
    $add++;
    }
      close IN2;
         
    #trimmed ($opts{g},'trimmed' ,$opts{n}, \%geno_hash);
    transpose('trimmed', $opts{n}, $add, 'transposed'); #transpose the matrix;
    adegenet('transposed', $opts{s}, $opts{o});
  }
    if  ($opts{h} == 0 ) {
    open (IN, "<", $opts{g}); 
    my %hash;
    my $size = $opts{n};
    open (OUT, ">", "selected");  
    
    
    foreach (<IN>) {
      chomp (my @line = split /\s/, $_);
      my $add = 0;
      my $site = 0;
      my $missing = 0;
      foreach my $m (@line[2..$#line]) {
	if ($m eq '2' || $m eq '1') {
	 $add++; $site++; 	 
       }
       if ($m eq '0') {
	 $site++;
       } 
       if ($m eq '-1') {
	 $site++; $missing++;
       }
       if ($add > 1 && $site == $size && ($missing/$site <= 0.2)) {
	 $hash{$line[0]}{$line[1]} = join ("\t",@line[2..$#line] ); 	
	 
       }
     }
    } 
    close IN;
    
    foreach (sort {$a cmp $b} keys %hash) { 
      my @array = ();
      foreach my $pos (keys %{$hash{$_}}){
	push (@array, $pos);
       }
      my $randomelement = $array[rand @array];
      print OUT $_, "\t", $randomelement, "\t", join("\t",$hash{$_}{$randomelement}), "\n";
    } 
    close OUT;
       
    open (IN2, "<", "selected");
    my $n = 0;
    foreach (<IN2>) {
      chomp(my @line = split /\t/, $_);
      $n++;   
    }
    close IN2;
    print "The number of selected sites now is: ", $n, "\n";
    
    trimmed ('selected','trimmed' ,$opts{n}, \%geno_hash);
    system("rm selected");
    transpose('trimmed', $opts{n}, $n, 'transposed'); #transpose the matrix;
    adegenet('transposed', $n, $opts{o});    
    }
    

    sub trimmed {
    my ($geno, $trim, $sample, $geno_hash) = @_;
    my %geno_hash = %{$geno_hash};
    open (IN, '<', $geno);   
    open (TRIM, '>',$trim);
    foreach (<IN>) {
      my $count = 1;
      chomp(my @line = split /\s+/, $_);
      foreach (@line[2..$#line]) {
	chomp();
	if ($count < $sample) {
	  $count++;
	  print TRIM  $geno_hash{$_}[0] . $geno_hash{$_}[1], "\t";
	  
	}      
	elsif  ($count == $sample) {
	  print TRIM  $geno_hash{$_}[0] . $geno_hash{$_}[1], "\n";
	}
      }
      
    }
    close IN;
    close TRIM;
    }

    
    
    sub adegenet {
      my ($in, $sites, $out) = @_;
      open (IN2, "<", $in);
      open (OPTo, '>', $out);
      my $count = 1;
      for ($count = 1; $count <= $sites; $count++) {
	print OPTo "\t", join ("", "Loc". $count);
      }
      print OPTo "\n";
      
      open (IN2, '<', 'transposed');
      $count = 1; 
      foreach (<IN2>) {
	print OPTo 'Ind'.$count, "\t", join ("", $_);
	$count++;   
      }
  
      unlink ($in); 
      close OPTo;
      close IN2;
    }
  }
  
  
  if ($opts{p}) {
    jasonBragg ($opts{g}, $opts{n}, 'out.JB.original',$opts{o}, \%geno_hash, $opts{s});
  }
  
  sub jasonBragg {
    my ($file, $size, $out, $final, $geno_hash, $snps) = @_;
    my %geno_hash = %{$geno_hash};
    my %hash;
    open (IN, '<', $file);
    open (OUT, '>', $out);
    foreach (<IN>) {
      my @line = split /\s/, $_;
      my $add = 0;
      my $site = 0;
      foreach my $m (@line[2..$#line]) {
       if ($m eq '2' || $m eq '1') {
	 $add++; $site++; 	 
       }
       if ($m eq '0') {
	 $site++;
       } 
       if ($add >= 2 ) { ## && $site == $size removed
	 $hash{$line[0]}{$line[1]} = join ("\t",@line[2..$#line] ); 	

       }
     }
    } 
    close IN;

   foreach (sort {$a cmp $b} keys %hash) { 
     my @array = ();
     foreach my $pos (keys %{$hash{$_}}){
       push (@array, $pos);
     }
      my $randomelement = $array[rand @array];
      print OUT $_, "\t", $randomelement, "\t", join("\t",$hash{$_}{$randomelement}), "\n";
   }
    close OUT;
    
    trimmed ('out.JB.original','trimmed', $size, \%geno_hash);
    my $j=0;
    open (STUPID, "<", 'out.JB.original');
    foreach (<STUPID>) {
    $j++;
    }
    transpose('trimmed', $size, $j, 'transposed'); #transpose the matrix;
    adegenet('transposed', $j, $final);

  }
  
}

####################################################################################################################################################

sub PCA {
  die(qq/
Usage PopGenomics.pl PCA [options]

Options: -g FILE raw genotype probability generated using ANGSD "-doGeno 32"
         -w INT  weighting or no weighting? if INT=1 weighting, if INT=2 no weighting [2]
         -i INT  if no weighting, the minimal minor allele frequency cutoff, requires w=2
         -z INT  file with SFS posterior probabilities [required if you want to weight each site by its probability of being variable], this is the binary output of sfstools after running ANGSD realSFS1 and optimSFS
         -s INT  number of sites to be analyzed
         -n INT  number of samples
         -b INT  block size
         -m INT  0 or 1 normalizations for the estimate of the 'covariance' matrix for PCA [0]
         -o FILE outfile name

\n/) if (!@ARGV);
  

  my %opts = (g=>undef, w=>2, i=>undef,s=>undef, N=>undef, b=>undef, m=>0, o=>undef,z=>undef);
  getopts('g:w:i:s:n:b:m:o:z:', \%opts);
  if ($opts{w} == 2) {
    die(qq/
option -i (minimal minor allele frequency cutoff) is required
\n/) unless ($opts{i});
  }
  
  if ($opts{w} == 1) {
    die(qq/
option -z (SFS posterior probabilities) is required
\n/) unless ($opts{z});
  }
  
  my $ngsCovar = 'ngsCovar';
  if ($opts{w} == 2)   {
    system ("  $ngsCovar -probfile $opts{g} -outfile  $opts{o} -nind  $opts{n} -nsites  $opts{s} -verbose 0 -block_size  $opts{b} -norm  $opts{m}  -minmaf  $opts{i}");
}
  if ($opts{w} == 1)   {
    system ("  $ngsCovar -probfile $opts{g} -outfile  $opts{o} -nind  $opts{n} -nsites  $opts{s} -verbose 0 -block_size  $opts{b} -norm  $opts{m}  -sfsfile $opts{z}");
  } 
  
  
}


####################################################################################################################################################

sub ANGSD {
 die(qq/
Usage PopGenomics.pl ANGSD [options]

Options: 

Basic:
         -b FILE  a file that contains names (and paths) of all BAM files (alignment) generated by the SamTools 
         -f FILE  a file that contains all sites to keep, file must end by ".keep"
         -r FILE  reference fasta file used to align reads and generate BAM alignment files listed in a file after "-b"
         -a FILE  ancestral file, if no ancestral file then just use reference fasta file for -a
         -F INT   1=folded 0=unfolded [1]. You have to do folded if an ancestral fasta is unavailable 
         -Q INT   minimal Phred quality score to keep a base [20]
         -q INT   minimal map quality [0]
         -t INT   number of threads [4]
         -g INT   genotype output options [2]
                  1 = print out major minor 
                  2 = print the called genotype as 0,1,2 (used by Format_converter.pl PCA)
                  4 = print the called genotype as AA, AC, AG, ... (used by PopGenomics.pl geno_to_structure) 
                  8 = print all 3 posts (major,major),(major,minor),(minor,minor)
                  16 = print the posterior of the called genotype
                  32 = somewhat different dumps the binary posterior for all samples, encoded as 3*nind double
                  64 = all above    
         -n INT   sample size
         -o INT   outfile Prefix

Theta Estimate:
         -T       estimating per-site thetas? [null]

SNP\/Genotype calling:
         -c INT   1 = call genotypes; 0 = no [0]
         -s INT   1 = call SNPs; 0 = no [0]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~         
         if c = 1
         -P FLOAT Posterior prob cutoff for calling genotypes [0.95]        
         -e INT   1 = estimate the posterior genotype probability based on the allele frequency as a prior
                  2 = estimate the posterior genotype probability assuming a uniform prior 
                  [1]
         -h INT   min depth to call genotypes [0]
         -d INT   Discard site if effective sample size below value. 0 indicates no filtering [0]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         if s = 1 
         -v FLOAT The p-value used for calling SNPs [1e-6]
         -m FLOAT Remove sites with MAF below [0]


Note: calling genotypes and snps should be done at the same time. For example, if you use c = 1 then s must be 1 as well. 

\n/) if (!@ARGV);
 
 my %opts = (b=>undef, f=>undef, r=>undef,a=>undef, F=>1, Q=>20, q=>0, c=>0, g=>2, o=>undef,t=>4,n=>undef,c=>0,s=>0,P=>0.95, e=>1, h=>0, d=>0, v=>1e-6,m=>0);
 getopts('b:f:r:a:F:Q:q:n:c:g:o:t:c:s:P:e:h:d:v:m:T', \%opts);
 my $angsd = 'angsd';
 my $emOptim = 'emOptim2';

 my $threads = $opts{t};
 system ("cut -f1 $opts{f} | uniq > pos");
 my $rf = 'rffile_' . $opts{o};
 open (IN, '<', 'pos');
 open (OUT, '>', $rf );
 foreach (<IN>) {
   chomp();
   print OUT $_, ":", "\n";
 }
 system ("rm pos");
 
 if ($opts{F} == 1 ) { #folded
   if ($opts{c} == 1) { #call genotypes
     if ($opts{s} == 1) { #call SNPs
       system ("$angsd -bam $opts{b} -sites $opts{f} -ref $opts{r} -anc $opts{a}  -only_proper_pairs 1  -minMapQ $opts{q} -minQ $opts{Q} -fold 1 -out $opts{o}  -GL 1  -doGeno $opts{g}  -doPost $opts{e}  -postCutoff $opts{P}   -doCounts 1 -doGlf 4 -geno_minDepth $opts{h} -minInd $opts{d} -SNP_pval $opts{v} -minMaf $opts{m}   -doMaf 2 -doMajorMinor 1 -doSaf 1 -rf $rf");
       system (" $emOptim $opts{o}.saf $opts{n} -P $opts{t} >  $opts{o}.saf.sfs") if $opts{T} ; 
       
       system (" $angsd -bam $opts{b} -sites $opts{f} -ref $opts{r} -anc $opts{a}  -only_proper_pairs 1  -minMapQ $opts{q} -minQ $opts{Q} -fold 1   -GL 1  -doGeno $opts{g}  -doPost $opts{e}  -postCutoff $opts{P}   -doCounts 1 -doGlf 4 -geno_minDepth $opts{h} -minInd $opts{d} -SNP_pval $opts{v} -minMaf $opts{m}   -doMaf 2 -doMajorMinor 1 -doSaf 1 -rf $rf  -out $opts{o}.thetas  -doThetas 1 -pest  $opts{o}.saf.sfs  ") if $opts{T};
         
    
       
     }
     if ($opts{s} == 0) {       
       system ("$angsd -bam $opts{b} -sites $opts{f} -ref $opts{r} -anc $opts{a}  -only_proper_pairs 1  -minMapQ $opts{q} -minQ $opts{Q} -fold 1 -out $opts{o}  -GL 1  -doGeno $opts{g}  -doPost $opts{e}  -postCutoff $opts{P}   -doCounts 1 -doGlf 4 -geno_minDepth $opts{h} -minInd $opts{d}  -doMaf 2 -doMajorMinor 1 -doSaf 1 -rf $rf");
       system (" $emOptim $opts{o}.saf $opts{n} -P $opts{t} >  $opts{o}.saf.sfs") if $opts{T};        
       system (" $angsd -bam $opts{b} -sites $opts{f} -ref $opts{r} -anc $opts{a}  -only_proper_pairs 1  -minMapQ $opts{q} -minQ $opts{Q} -fold 1  -GL 1  -doGeno $opts{g}  -doPost $opts{e}  -postCutoff $opts{P}   -doCounts 1 -doGlf 4 -geno_minDepth $opts{h} -minInd $opts{d}  -doMaf 2 -doMajorMinor 1 -doSaf 1 -rf $rf  -out $opts{o}.thetas  -doThetas 1 -pest  $opts{o}.saf.sfs  ") if $opts{T};
      
     }  
   }
   if ($opts{c} == 0) { 
     
     if ($opts{s} == 1) { #call SNPs
       system ("$angsd -bam $opts{b} -sites $opts{f} -ref $opts{r} -anc $opts{a}  -only_proper_pairs 1  -minMapQ $opts{q} -minQ $opts{Q} -fold 1 -out $opts{o}  -GL 1  -doGeno $opts{g}  -doPost $opts{e} -SNP_pval $opts{v} -minMaf $opts{m} -doMaf 2 -doMajorMinor 1 -doSaf 1 -rf $rf");
       system (" $emOptim $opts{o}.saf $opts{n} -P $opts{t} >  $opts{o}.saf.sfs") if $opts{T}; 
       
       system (" $angsd -bam $opts{b} -sites $opts{f} -ref $opts{r} -anc $opts{a}  -only_proper_pairs 1  -minMapQ $opts{q} -minQ $opts{Q} -fold 1  -GL 1  -doGeno $opts{g}  -doPost $opts{e} -SNP_pval $opts{v} -minMaf $opts{m} -doMaf 2 -doMajorMinor 1 -doSaf 1 -rf $rf   -out $opts{o}.thetas  -doThetas 1 -pest  $opts{o}.saf.sfs ") if $opts{T};
         
     }
     if ($opts{s} == 0) {       
       system ("$angsd -bam $opts{b} -sites $opts{f} -ref $opts{r} -anc $opts{a}  -only_proper_pairs 1  -minMapQ $opts{q} -minQ $opts{Q} -fold 1 -out $opts{o}  -GL 1  -doGeno $opts{g}  -doPost $opts{e} -doMaf 2 -doMajorMinor 1 -doSaf 1 -rf $rf");
       system (" $emOptim $opts{o}.saf $opts{n} -P $opts{t} >  $opts{o}.saf.sfs") if $opts{T};        
       system (" $angsd -bam $opts{b} -sites $opts{f} -ref $opts{r} -anc $opts{a}  -only_proper_pairs 1  -minMapQ $opts{q} -minQ $opts{Q} -fold 1   -GL 1  -doGeno $opts{g}  -doPost $opts{e} -doMaf 2 -doMajorMinor 1 -doSaf 1 -rf $rf -out $opts{o}.thetas  -doThetas 1 -pest  $opts{o}.saf.sfs ") if $opts{T};
      
     } 
   }
 }
 
  if ($opts{F} == 0 ) { #unfolded
   if ($opts{c} == 1) { #call genotypes
     if ($opts{s} == 1) { #call SNPs
       system ("$angsd -bam $opts{b} -sites $opts{f} -ref $opts{r} -anc $opts{a}  -only_proper_pairs 1  -minMapQ $opts{q} -minQ $opts{Q} -fold 1 -out $opts{o}  -GL 1  -doGeno $opts{g}  -doPost $opts{e}  -postCutoff $opts{P}   -doCounts 1 -doGlf 4 -geno_minDepth $opts{h} -minInd $opts{d} -SNP_pval $opts{v} -minMaf $opts{m}   -doMaf 2 -doMajorMinor 1 -doSaf 1 -rf $rf");
       my $unfolded = 2*$opts{n};
       system (" $emOptim $opts{o}.saf $unfolded -P $opts{t} >  $opts{o}.saf.sfs") if $opts{T} ; 
       
       system (" $angsd -bam $opts{b} -sites $opts{f} -ref $opts{r} -anc $opts{a}  -only_proper_pairs 1  -minMapQ $opts{q} -minQ $opts{Q} -fold 1   -GL 1  -doGeno $opts{g}  -doPost $opts{e}  -postCutoff $opts{P}   -doCounts 1 -doGlf 4 -geno_minDepth $opts{h} -minInd $opts{d} -SNP_pval $opts{v} -minMaf $opts{m}   -doMaf 2 -doMajorMinor 1 -doSaf 1 -rf $rf    -out $opts{o}.thetas  -doThetas 1 -pest  $opts{o}.saf.sfs ") if $opts{T} ;
         
     }
     if ($opts{s} == 0) {       
       system ("$angsd -bam $opts{b} -sites $opts{f} -ref $opts{r} -anc $opts{a}  -only_proper_pairs 1  -minMapQ $opts{q} -minQ $opts{Q} -fold 1 -out $opts{o}  -GL 1  -doGeno $opts{g}  -doPost $opts{e}  -postCutoff $opts{P}   -doCounts 1 -doGlf 4 -geno_minDepth $opts{h} -minInd $opts{d}  -doMaf 2 -doMajorMinor 1 -doSaf 1 -rf $rf");
       my $unfolded = 2*$opts{n};
       system (" $emOptim $opts{o}.saf $unfolded -P $opts{t} >  $opts{o}.saf.sfs") if $opts{T} ;        
       system ("$angsd -bam $opts{b} -sites $opts{f} -ref $opts{r} -anc $opts{a}  -only_proper_pairs 1  -minMapQ $opts{q} -minQ $opts{Q} -fold 1  -GL 1  -doGeno $opts{g}  -doPost $opts{e}  -postCutoff $opts{P}   -doCounts 1 -doGlf 4 -geno_minDepth $opts{h} -minInd $opts{d}  -doMaf 2 -doMajorMinor 1 -doSaf 1 -rf $rf    -out $opts{o}.thetas  -doThetas 1 -pest  $opts{o}.saf.sfs ") if $opts{T};
      
     }  
   }
   if ($opts{c} == 0) { 
        
     if ($opts{s} == 1) { #call SNPs
       system ("$angsd -bam $opts{b} -sites $opts{f} -ref $opts{r} -anc $opts{a}  -only_proper_pairs 1  -minMapQ $opts{q} -minQ $opts{Q} -fold 1 -out $opts{o}  -GL 1  -doGeno $opts{g}  -doPost $opts{e} -SNP_pval $opts{v} -minMaf $opts{m} -doMaf 2 -doMajorMinor 1 -doSaf 1 -rf $rf");
       my $unfolded = 2*$opts{n};
       system (" $emOptim $opts{o}.saf $unfolded -P $opts{t} >  $opts{o}.saf.sfs") if $opts{T} ; 
       
       system ("$angsd -bam $opts{b} -sites $opts{f} -ref $opts{r} -anc $opts{a}  -only_proper_pairs 1  -minMapQ $opts{q} -minQ $opts{Q} -fold 1   -GL 1  -doGeno $opts{g}  -doPost $opts{e} -SNP_pval $opts{v} -minMaf $opts{m} -doMaf 2 -doMajorMinor 1 -doSaf 1 -rf $rf  -out $opts{o}.thetas  -doThetas 1 -pest  $opts{o}.saf.sfs ") if $opts{T} ;
         
     }
     if ($opts{s} == 0) {       
       system ("$angsd -bam $opts{b} -sites $opts{f} -ref $opts{r} -anc $opts{a}  -only_proper_pairs 1  -minMapQ $opts{q} -minQ $opts{Q} -fold 1 -out $opts{o}  -GL 1  -doGeno $opts{g}  -doPost $opts{e} -doMaf 2 -doMajorMinor 1 -doSaf 1 -rf $rf");
       my $unfolded = 2*$opts{n};
       system (" $emOptim $opts{o}.saf $unfolded -P $opts{t} >  $opts{o}.saf.sfs") if $opts{T} ;        
       system ("$angsd -bam $opts{b} -sites $opts{f} -ref $opts{r} -anc $opts{a}  -only_proper_pairs 1  -minMapQ $opts{q} -minQ $opts{Q} -fold 1   -GL 1  -doGeno $opts{g}  -doPost $opts{e} -doMaf 2 -doMajorMinor 1 -doSaf 1 -rf $rf  -out $opts{o}.thetas  -doThetas 1 -pest  $opts{o}.saf.sfs") if $opts{T};
      
     } 
   }
 }
}

####################################################################################################################################################


sub SNPID {
	die(qq/

Usage PopGenomics.pl SNPID [options]

Options: -p INT   minimum probability of site being variable [0.95]
         -b INT   if INT=1 output in .sfs.pos format, if INT=2 output in .bed format [2]
         -d INT   if INT=1 assume folded SFS, if INT=2 assume unfolded [2]
         -f FILE  tabulated posterior probs. for each site ouputted by sfstools
         -l FILE  .sfs.pos file from ANGSD -realSFS 1 corresponding to option -f input file
         -o FILE  outfile name
\n/) if (!@ARGV);
	my %opts = (p=>0.95, b=>2, d=>1, f=>undef, l=>undef, o=>undef);
	getopts('p:b:d:n:f:l:o:', \%opts);
	my $minprob = 1 - $opts{p};
	open(PROBS, '<', $opts{f});
	open(POS, '<', $opts{l});
	open(OUT, '>', $opts{o});
	my $start;
	while (<PROBS>) {	  
	  my @pos = split /\s+/, <POS>;
	  my @probs = split;
	  if ($opts{d} == 1) {
	    if (($probs[0]) <= $minprob) {		
		if ($opts{b} == 1) {
		  print OUT "$pos[0]\t$pos[1]\n";
		} 
		else {
		  $start = $pos[1]-1;
		  print OUT "$pos[0]\t$start\t$pos[1]\n";
		}
	      }
	  }
	  
	  else {
	    if (($probs[0]+$probs[-1]) <= $minprob) {
	      if ($opts{b} == 1) {
		print OUT "$pos[0]\t$pos[1]\n";
	      } else {
		$start = $pos[1]-1;
		print OUT "$pos[0]\t$start\t$pos[1]\n";     
	      }
	    }
	  }
	}
	close PROBS;
	close POS; 
	close OUT;
      }


####################################################################################################################################################

sub SNP2D {
	die (qq/
Usage: PopGenomics.pl SNP2D [options]

Options: -a INT    pop1 sfs category
	 -b INT    pop2 sfs category
	 -f FILE   sfstools tabulated posterior probs for pop1
	 -g FILE   sfstools tabulated posterior probs for pop2
	 -l FILE   .sfs.pos file from ANGSD -realSFS 1 corresponding to option -f\/g input files\n
Note: sfs can be folded or unfolded

\n/) if (!@ARGV);
	my %opts = (a=>undef, b=>undef, f=>undef, g=>undef, l=>undef);
	getopts('a:b:f:g:l:', \%opts);
	open(POP1, '<', $opts{f});
	open(POP2, '<', $opts{g});
	open(POS, '<', $opts{l});
	my $start;
	while (<POS>) {
		my @pos = split;
		my $p1 = <POP1>;
		my $cat1 = sfscat($p1);
		my $p2 = <POP2>;
		my $cat2 = sfscat($p2);
		if ($cat1==$opts{a} && $cat2==$opts{b}) {
			$start = $pos[1]-1;
			print "$pos[0]\t$start\t$pos[1]\n";
		}
	}
	sub sfscat{
		my @probs = split /\s+/, $_[0];
		my $max = $probs[0]; my $count = -1; my $cat = 0;
		foreach(@probs) {
			$count++;
			if ($max < $_) {
				$max = $_;
				$cat = $count;
			}
		}
		return($cat);
	}
}


####################################################################################################################################################

sub FST {
  die(qq/
Usage PopGenomics.pl FST [options]

Options: -b CHR  A folder contain BAM files for each population (e.g. KBT01_BAM.txt.. KBT02_BAM.txt, ....). Files must end by ".txt"
         -f FILE A file that contains all sites to keep, file must end by ".keep"
         -r FILE Reference fasta sequence file
         -a FILE Ancestral fasta sequence file
         -s INT  Number of sites
         -t INT  Number of threads [4]
         -o CHR  A folder where results will go
         -Q INT  Minimal Phred quality score to keep a base [20]
         -q INT  minimal map quality [0]
         -G INT  Methods that are used to calculate genotype likelihood [1] 
                  1=SamTools 
                  2=GATK 
                  3=soapSNP 
         -g INT   genotype calling output options [3]
                  1 = print out major minor 
                  2 = print the called genotype as 0,1,2 (used by Format_converter.pl PCA)
                  4 = print the called genotype as AA, AC, AG, ... (used by PopGenomics.pl geno_to_structure) 
                  8 = print all 3 posts (major,major),(major,minor),(minor,minor)
                  16 = print the posterior of the called genotype
                  32 = somewhat different dumps the binary posterior for all samples, encoded as 3*nind double
                  64 = all above
         -l INT  block size [100000]

          

\n/) if (!@ARGV);
  
  my %opts = (b=>undef, f=>undef, r=>undef, a=>undef, s=>undef, Q=>20, q=>0, G=>1, l=>100000, o=>undef, t=>4,g=>3);
  getopts('b:f:r:a:s:Q:q:G:l:o:t:g:', \%opts);
  
  my $angsd = 'angsd';
  my $emOptim = 'emOptim2';
  my $ngsFST = 'ngsFST';
  my $ngs2dSFS = 'ngs2dSFS';
  my $site = $opts{s};
  my $threads = $opts{t};
  my $gcall = $opts{g};
  system ("cut -f1 $opts{f} | uniq > pos");
  my $rf = 'rffile';
  open (IN, '<', 'pos');
  open (OUT, '>', $rf );
  foreach (<IN>) {
   chomp();
   print OUT $_, ":", "\n";
 }
  system ("rm pos");
  
  my $dir;
  
  if ($opts{b} =~ m/\/$/ ){
    $dir = $opts{b}; 
  }
  else {
    $dir = $opts{b} . "/";
  }
  
  
  my $dir1;
  
  if ($opts{o} =~ m/\/$/ ){
    $dir1 = $opts{o}; 
  }
  else {
    $dir1 = $opts{o} . "/";
  }

 
    my @bams = <$dir*.txt>;
    foreach (<@bams>) {
      my $a = 0;
      my $prefix = $1 if (basename($_) =~ m /(\S+).txt/);
      open (IN1, "<", $_);
      foreach (<IN1>) {
	chomp($_);
	$a++;
      }    
	system ("$angsd -bam $dir$prefix.txt -sites $opts{f} -ref $opts{r} -anc $opts{a}  -only_proper_pairs 1  -minMapQ $opts{q} -minQ $opts{Q} -out $prefix  -GL $opts{G}  -doGeno $gcall  -doPost 1 -doMaf 2 -doMajorMinor 1 -doSaf 1 -rf $rf -nThreads $threads");

    } #foreach (<@bams>)
    system ("rm rffile "); 
 
  
    my @probs = <*.saf>;
    my $size = scalar (@probs); 
      for (my $i = 0; $i < $size; $i++) {
      my $a = 0;
      my $prefix1 = $1 if (basename($probs[$i]) =~ m /(\S+).saf/);
      my $bam1 = $dir . $prefix1 . ".txt";
      open (IN1, "<", $bam1);
      foreach (<IN1>) {
	chomp($_);
	$a++;
      }
      close IN1;
      
      for (my $j = $i+1; $j < $size; $j++) { 
	my $b = 0;
	my $prefix2 = $1 if (basename($probs[$j]) =~ m /(\S+).saf/);
	my $bam2 = $dir . $prefix2 . ".txt";
	open (IN2, "<", $bam2);
	foreach (<IN2>) {
	  chomp($_);
	$b++;
	}
	close IN2;	
	if ($prefix1 ne $prefix2) {
	  my $twod = $prefix1 . "_" . $prefix2 . ".2dsfs";
	  my $file1 =  $prefix1.".saf";
	  my $file2 =  $prefix2.".saf";

	    system ("$ngs2dSFS -postfiles $file1 $file2 -outfile $twod -relative 1 -nind $a $b -maxlike 1 -block_size $opts{l} -islog 1  -nsites $site");
	    system ("$ngsFST -postfiles $file1 $file2 -priorfile $twod -outfile  $dir1$prefix1\_$prefix2.FST -nind $a $b -nsites $site -block_size $opts{l} -islog 1");
	  
	} #if ($prefix1 ne $prefix2)
      } 
    }
  
  
  #system ("rm *.prob"); 
  
  my @FST = <$dir1*FST>; 
  my $global_num = 0;
  my $global_sum = 0;
  my $out = $dir1 . "Fst.final";
  open (OUT, ">", $out);
  foreach my $file (@FST) {
    my $prefix = $1 if (basename($file) =~ m /(\S+).FST/);
    open (IN, "<", $file);
    my $num = 0;
    my $sum = 0;
    
    foreach (<IN>) {
      chomp(my @line = split /\t/, $_);
      $num += $line[0];
      $global_num += $line[0];
      $sum += $line[1];
      $global_sum += $line[1];
    }
    
    print OUT  "Pairwise Fst of", "\t", $prefix, " is: ", $num/$sum, "\n";
    close IN;
   }
  print OUT "Global Fst is:" , $global_num/$global_sum, "\n";
}


####################################################################################################################################################


sub SPA {
  die(qq/
Usage PopGenomics.pl SPA [options]

Options: -g FILE Raw genotype probability generated using ANGSD "-doGeno 2" (e.g. Contig29 294 0 1 2 -1 -1 2 1....)
         -o FILE Outfile perfix
         -p      Randomly selects one snp per contig, kick off non-varibale sites
         -n INT  Sample size (need -p)
         -s INT  Number of sites

Note: ignore singletons and doubletons

\n/) if (!@ARGV);
  
  
  my %opts = (g=>undef,o=>undef, n=>undef,s=>undef);
  getopts('g:o:n:s:p', \%opts);
  
  
  unless ($opts{p}) { 
    open (IN, "<", $opts{g});
    my $out = 'trimmed';
    my $out1 = 'SNP_id.txt';
    open (OUT,">", $out);
    open (OUT1,">", $out1);
    foreach (<IN>) {
      my @line = split /\s+/, $_;
      my $add = 0;
      my $site = 0;
      my $missing =0;
      my $rare = 0;
       foreach my $m (@line[2..$#line]) {
	if ($m eq '2' ) {
	  $add++; $site++; $rare += 2;
	  }
	if ($m eq '1') {
	  $add++; $site++; $rare++;	 
	}
	if ($m eq '0') {
	  $site++;
	} 
	if ($m eq '-1') {
	  $site++; $missing++;
	}
      }
      if ($add > 0 && ($missing/$site <= 0.1) && $rare > 4 && (2*$site - $rare) > 4) {
	print OUT join "\t",@line[2..$#line], "\n" ; 
	print OUT1 $line[0], "\t", $line[1], "\n";
       }
    }
    close IN;
    close OUT;
    close OUT1;
    open (IN2,"<", $out);
    my $add;
    while (<IN2>) {
    $add++;

    }
    my $out2 = $opts{o} . "_SPA.geno";
    transpose($out, $opts{n}, $add, $out2);
  }
  
  if ($opts{p}) {
    open (IN, "<", $opts{g}); 
    my %hash;
    my $size = $opts{n};
    open (OUT, ">", $opts{o} . "_selected");  
    
    
    foreach (<IN>) {
      chomp (my @line = split /\s/, $_);
      my $add = 0;
      my $site = 0;
      foreach my $m (@line[2..$#line]) {
	if ($m eq '2' || $m eq '1') {
	 $add++; $site++; 	 
       }
       if ($m eq '0') {
	 $site++;
       } 
       if ($m eq '-1') {
	 $site++;
       }
       if ($add > 0 && $site == $size) {
	 $hash{$line[0]}{$line[1]} = join ("\t",@line[2..$#line] ); 	
	 
       }
     }
    } 
    close IN;
    
    foreach (sort {$a cmp $b} keys %hash) { 
       my @array = ();
       foreach my $pos (keys %{$hash{$_}}){
	 push (@array, $pos);
       }
       my $randomelement = $array[rand @array];
       print OUT $_, "\t", $randomelement, "\t", join("\t",$hash{$_}{$randomelement}), "\n";
     } 
    close OUT;
    
    my $before = $opts{o} . "_before";
    open (IN2, "<", $opts{o} . "_selected");
    open (OUT2, ">", $opts{o} . "_before");
    my $n = 0;
    foreach (<IN2>) {
	chomp(my @line = split /\t/, $_);
	$n++;
	print OUT2 join("\t", @line[2..$#line]), "\n"; 
	
      }
    close IN2;
    close OUT2;
    system ("rm $opts{o}_selected");
    
    my $out2 = $opts{o} . "_SPA.geno";
    transpose($before, $opts{n}, $n , $out2);
    
    
  }
  
  
} 
  
  
####################################################################################################################################################


sub TREEMIX {
  die(qq/
Usage PopGenomics.pl TREEMIX [options]

Options: -g FILE Raw genotype probability generated using ANGSD "-doGeno 2" (e.g. Contig29 294 0 1 2 -1 -1 2 1....)
         -o FILE Outfile perfix
         -p      Randomly selects one snp per contig, kick off non-varibale sites
         -n INT  Sample size (need -p)
         -z FILE population file
         -w INT  Number of populations
         -s INT  Number of sites

\n/) if (!@ARGV);
  
  
  my %opts = (g=>undef,o=>undef, n=>undef,s=>undef,z=>undef,w=>undef);
  getopts('z:g:o:w:n:s:p', \%opts);
  
  my %pop;
  open (POP, "<", $opts{z});
  my $d = 1;
  foreach (<POP>) {
    chomp  (my @line = split /\s+/, $_);
    
    $pop{$d} = $line[1];
    $d++;    
  }
  
  close POP;   
  
  if ($opts{p}) {
    my $new = unique ($opts{g}, $opts{n});
    my $final = treemix($new, \%pop, $opts{w}, $opts{o});
    
    unlink ($new);
    system ("gzip $final");
  }
  unless ($opts{p}){
    my $final = treemix($opts{g}, \%pop, $opts{w}, $opts{o});
    system ("gzip $final");
  }
  
  sub unique {
    my ($geno, $size) = @_;
    open (IN, "<", $geno);
    my %hash;
    foreach (<IN>) {
      chomp (my @line = split /\s/, $_);
      my $add = 0;
      my $site = 0;
      foreach my $m (@line[2..$#line]) {
	if ($m eq '2' || $m eq '1') {
	  $add++; $site++; 	 
	}
	if ($m eq '0') {
	  $site++;
	} 
	if ($m eq '-1') {
	  $site++;
	}
	if ($add > 0 && $site == $size) {
	  $hash{$line[0]}{$line[1]} = join ("\t",@line[2..$#line] ); 	
	  
	}
      }
    } 
    close IN;
    my $new_geno = 'unique.txt';
    open (OUT, ">", $new_geno);
    #my $fh = select(OUT);
    #$| = 1;
    #select($fh);
    foreach (sort {$a cmp $b} keys %hash) { 
      my @array = ();
      foreach my $pos (keys %{$hash{$_}}){
	push (@array, $pos);
      }
      my $randomelement = $array[rand @array];
      print OUT $_, "\t", $randomelement, "\t", join("\t",$hash{$_}{$randomelement}), "\n";
    }
    close OUT;
    return ($new_geno);
  }   
  
  
  
  sub treemix {
    my ($geno,$pop, $popnum, $prefix) = @_;
    my %pop = %{$pop};
    my %ind;
    open (IN, "<", $geno);
    my $s = 1;
    foreach (<IN>) {
      chomp(my @line = split /\t+/, $_);
      #print $line[0],"\t",$line[1],"\n";
      my $c = 1;
      foreach (@line[2 .. $#line]) {
	if ($_ !~ m/^$/) {
	  my $ref = 0;
	  my $alt = 0;
	  
	  if ($_ eq '0') {
	    $ref = $ref+2;
	  } 
	  if ($_ eq '1'){
	    $ref = $ref+1; $alt = $alt+1;
	  }
	  if ($_ eq '2'){
	    $alt = $alt+2;  
	  }
	  if ($_ eq '-1'){
	    $ref = $ref+0;
	    $alt = $alt+0;
	  }
	  
	  $ind{$c}{$s} = {'ref' => $ref,'alt' => $alt, 'pop'=> $pop{$c}};   
	  $c++;
	}
      } 
      $s++;
      #print $s, "\n";
    }
   
    my %pop_all;
    for (my $ID = 1; $ID<= $popnum; $ID++) { 
    foreach my $i (sort {$a <=> $b} keys (%ind)) {
      foreach my $j  (sort {$a <=> $b} keys %{$ind{$i}}){	
	if ($ind{$i}{$j}{'pop'} =~  /\b$ID\b/ ) {	  	  
	  $pop_all{$ID}{$j}{'ref'} += $ind{$i}{$j}{'ref'};
	  $pop_all{$ID}{$j}{'alt'} += $ind{$i}{$j}{'alt'};
	} 
	
	else {
	  last;
	}
      }
    }    
  } 
    my $out = 'out';
    open (OUT, ">", $out);
    my $sites =$s-1;
    foreach my $popid (sort {$a <=> $b} keys (%pop_all)) {
      foreach my $snp  (sort {$a <=> $b} keys %{$pop_all{$popid}}){
	if ($snp  < $sites) {
	  print OUT  $pop_all{$popid}{$snp}{'ref'}, "," , $pop_all{$popid}{$snp}{'alt'}, "\t";
	}
	elsif ($snp =$sites) {
	  print OUT   $pop_all{$popid}{$snp}{'ref'}, "," , $pop_all{$popid}{$snp}{'alt'}, "\n";
	}
      }
    }
    close OUT; 
    my $final =  $prefix . "_treemix.snp"; 
    transposed ($out,  $sites, $popnum, $final);  
    return ($final);
    
  } 


 sub transposed {
    my ($file, $size, $site1, $out) = @_;
    open (OUT1, '>', $out); 
    for (my $j =1; $j<=$site1; $j++) {
      if ($j < $site1) {
      print OUT1 "pop",$j,"\t";
      }
      elsif ($j = $site1) {
      print OUT1 "pop",$j,"\n";
      } 
    }
      
    for (my $i = 1; $i <= $size; $i++) {
      my $count = $site1;
      open (IN1, '<', $file);
      foreach (<IN1>) {
	chomp();	  
	if ($count > 1) {
	  my @line = split /\t+/, $_;
	  print OUT1 $line[$i-1], "\t";
	  $count--;
	}
	elsif ($count == 1) {
	  my @line = split /\t+/, $_;
	  print OUT1 $line[$i-1], "\n";
	}
	else {
	  last;
	}
      }
    }
    close IN1;
    close OUT1;
    unlink ($file);
  }
}


####################################################################################################################################################

sub GEODIST {
  die (qq/
Usage: PopGenomics.pl GEODIST [options]

Options: -f FILE    a file containing geographic corrdinates (no header;three columns: ID  lats  longs); For example: KBT01_23  37.69924  -119.58647
         -g FILE    a file containing genetic distance 
         -s INT     number of samples
         -u CHAR    unit: M for miles and K for kilometers; 
	 -o file    output name 


\n/) if (!@ARGV);
  my %opts = (f=>undef,s=>undef,u=>'K',o=>undef,g=>undef);
  getopts('f:s:u:o:g:', \%opts);
  
  
  my $file = $opts{f};
  my $dir = dirname($file);
  my $loc = $opts{s};
  my $out = $dir . "/". $opts{o};
  my $unit = $opts{u};
  my $gendis = $opts{g};
  
  my %geo;
  open (IN, "<", $file);
  
  foreach (<IN>) {
    chomp (my @line =split /\s/, $_);
    my $id1 = $1 if ($line[0] =~ m/\S+_(\d+)/); 
    $geo{$id1} = {'lat' => $line[1], 'lon' => $line[2]};
  }
  close IN;
  
  open (OUT, ">", $out);
  my %zero_geo;
 
   open (DIST, "<", $gendis);
  print OUT "GENETIC_DISTANCE","\n";
  my $header = <DIST>;
  my $p = 1;
  foreach (<DIST>) {
    chomp (my @line =split /\s/, $_);
    my @stupid_array;
    foreach (@line) {
      chomp (my @item =split /\s/, $_);
      next unless ($_);
      push (@stupid_array, $_);
    }
    
    for (my $q = $p+1; $q <= $loc; $q++) {	
	print OUT $p, "\t", $q, "\t", $stupid_array[$q-1],"\n";     
    }
    $p++;
  }
  close DIST;
  
  
  
  print OUT "GEOGRAPHIC_DISTANCE", "\n";
  
  for (my $i = 1; $i < $loc; $i++) {	    
    for (my $j = $i+1; $j <= $loc; $j++) {
      my $lat1 = $geo{$i}{'lat'};
      my $lon1 = $geo{$i}{'lon'};
      my $lat2 = $geo{$j}{'lat'};
      my $lon2 = $geo{$j}{'lon'};
     if (distance($lat1, $lon1, $lat2, $lon2, $unit) == 0) {
       print OUT $i, "\t", $j, "\t",1e-100,"\n";
       $zero_geo{$i}{$j}++;
	next;
      }
     elsif (distance($lat1, $lon1, $lat2, $lon2, $unit) > 0) {
	print OUT $i, "\t", $j, "\t",distance($lat1, $lon1, $lat2, $lon2, $unit),"\n";
      }
    }  
  }
  
  close OUT;
  
  
  
  
  my $pi = atan2(1,1) * 4;
  sub distance {
    my ($lat1, $lon1, $lat2, $lon2, $unit) = @_;
    my $theta = $lon1 - $lon2;
    my $dist = sin(deg2rad($lat1)) * sin(deg2rad($lat2)) + cos(deg2rad($lat1)) * cos(deg2rad($lat2)) * cos(deg2rad($theta));
    $dist  = acos($dist);
    $dist = rad2deg($dist);
    $dist = $dist * 60 * 1.1515;
    if ($unit eq "K") {
      $dist = $dist * 1.609344;
    } elsif ($unit eq "N") {
      $dist = $dist * 0.8684;
    }
    return ($dist);
  }    
}





####################################################################################################################################################


sub Geneland {

  die(qq/
Usage PopGenomics.pl Geneland [options]

Options: -g FILE  Raw genotype probability generated using ANGSD "-doGeno 4" (e.g. Contig29 294 TT TT TA....)
         -o CHAR  Outfile prefix
         -s INT   Number of loci
         -d FILE  Geographic coordinates file (lat long)
	 -n INT   Number of individuals
         -p       if p is supplied, Random choose one SNP per contig.
\n/) if (!@ARGV);
  
  my %opts = (g=>undef, o=>undef, s=>undef,d=>undef, n=>undef);
  getopts('g:o:s:d:n:p', \%opts);
  
  my %genos = ('AA' => 0 , 'AC' => 1, 'CA'=>1, 'AG' => 2, 'GA' => 2,  'AT' => 3, 'TA'=>3, 'CC'=> 4, 'CG'=>5, 'GC'=>5, 'CT' => 6, 'TC' => 6, 'GG'=>7, 'GT'=>8, 'TG'=>8, 'TT'=>9, 'NN' => -9);
  # A = 1, C = 2, G = 3, T = 4
  my %genos2 = ('0' => ['1','1'], '1' => ['1','2'], '2' => ['1','3'], '3' => ['1','4'], '4'=>['2','2'], '5'=>['2','3'], '6' => ['2','4'], '7'=>['3','3'], '8'=>['3','4'], '9'=>['4','4'], '-9' => ['0','0'] );
 
  
  
  my $dir = dirname($opts{g}) . "/";
  my $geo = $opts{d};
  my $geout = $dir . $opts{o} . "_UTM.txt";  
  open (GEO, "<", $geo); 
  open (GOUT, ">", $geout);
  foreach (<GEO>) {
    chomp (my @line = split /\s+/, $_);
    my $proj = Geo::Proj4->new(proj => "utm", zone => 10 );
    my ($x, $y) = $proj->forward($line[0], $line[1]);
    print GOUT $y, "\t", $x, "\n";
  }
 close GEO; close GOUT;
	
  unless ($opts{p}) {
    my $start0 = time;
    my $out = 'cleaned';
    trim($opts{n},$opts{s},$opts{g},$out,\%genos);
    my $time0 = int(time - $start0);
    print "Xixi...Trimmed original genotype matrix in $time0 sec!\n";
    
    my $start1 = time;
    my $out2= 'converted2';
    transpose($out, $opts{n}, $opts{s}, $out2); #transpose the matrix;
    my $time1 = int(time - $start1);
    print "Hehe...Transposed cleaned genotype matrix in $time1 sec! \n";
    
    my $start2 = time;
    my $final = $dir. $opts{o} . "_genotype.txt";
    convert2($out2, $final, \%genos2, $opts{s}); #convert the transposed matrix to input for geneland;
    my $time2 = int(time - $start2);
    print "Hoho... Converted transposed genotype matrix to geneland input in $time1 sec!\n";
  }
  
  
  if ($opts{p}) {
    open (IN, "<", $opts{g}); 
    my %hash;
	my %hash1;    
	my $size = $opts{n};
    open (OUT, ">", "selected");  
    
    
    foreach (<IN>) {
      chomp (my @line = split /\s/, $_);
      my $site = 0;
      my @geno;
      foreach my $m (@line[2..$#line]) {
	if ($m ne 'NN') {
	push (@geno, $genos{$m});
	$site++;	 
	}
	if ($m eq 'NN') {
	  $site++;
	} 
	}
	if ((min (@geno) != max(@geno)) && $site == $size) {
	  $hash{$line[0]}{$line[1]} = join ("\t",@line[2..$#line] ); 	
      }
    } 
    close IN;
    
    foreach (sort {$a cmp $b} keys %hash) { 
      my @array = ();
      foreach my $pos (keys %{$hash{$_}}){
	push (@array, $pos);
       }
      my $randomelement = $array[rand @array];
      print OUT $_, "\t", $randomelement, "\t", join("\t",$hash{$_}{$randomelement}), "\n";
    } 
    close OUT;
    
    
    open (IN2, "<", "selected");
    my $n = 0;
    foreach (<IN2>) {
      chomp(my @line = split /\t/, $_);
      $n++;   
    }
    close IN2;
    print "The number of selected sites now is: ", $n, "\n";
 
    
    my $start0 = time;
    my $out = 'cleaned';
    trim($opts{n},$opts{s},"selected",$out,\%genos);
    my $time0 = int(time - $start0);
    print "Xixi...Trimmed original genotype matrix in $time0 sec!\n";
    
    my $start1 = time;
    my $out2= 'converted';
    transpose($out, $opts{n}, $n, $out2); #transpose the matrix;
    my $time1 = int(time - $start1);
    print "Hehe...Transposed cleaned genotype matrix in $time1 sec! \n";
    
    my $start2 = time;
    my $final = $dir. $opts{o} . "_genotype.txt";
    convert2($out2, $final, \%genos2, $n); #convert the transposed matrix to input for geneland;
    my $time2 = int(time - $start2);
    print "Hoho... Converted transposed genotype matrix to geneland input in $time1 sec!\n";
 
  }
  
   
  sub convert2 {
    my ($file, $final, $genos2, $loci) = @_;
    my %genos2 = %{$genos2};
    open (IN, '<', $file);
    open (OUT,'>', $final);

    foreach (<IN>) {
      chomp (my @line = split /\s+/, $_);
      for (my $i=0; $i<= $loci-1; $i++) {
      	if ($i < $loci-1) {

	  print OUT $genos2{$line[$i]}[0], "\t", $genos2{$line[$i]}[1], "\t";
	}
	if ($i == $loci-1) {
	  print OUT $genos2{$line[$i]}[0], "\t", $genos2{$line[$i]}[1], "\n";	
	}
      }	
      
    }
    close OUT;
    close IN;
    unlink ($file);
    
  }
}

##########################################################################################################


sub GENEPOP {
  die(qq/
Usage PopGenomics.pl GENEPOP [options]

Options: -g FILE raw genotype probability generated using ANGSD "-doGeno 2" (e.g. Contig29 294 0 1 2 -1 -1 2 1....)
         -n INT  sample size
         -s INT  number of loci
         -o FILE outfile name
         -h INT  1 = all sites; 0 = one snp per contig [1]
         -p      Jason Bragg method for choosing SNPs: 1) Selects one snp per contig; 2) A SNP must have a genotype called in all samples; 3) It must be parsimony informative (minor allele present in > 1 sample) - note this has been modified below; 4) If multiple SNPs in a contig fulfil these criteria, one SNP is chosen at random. If -p is not used, all sites will be converted. 

Note: you can only choose either -h or -p

\n/) if (!@ARGV);
  
  
  my %opts = (g=>undef, n=>undef, s=>undef,o=>undef, h=>1);
  getopts('n:g:s:o:h:p', \%opts);
  my %geno_hash = ('-1' => ['00','00'], '0' => ['01','01'], '1' => ['01','02'], '2' => ['02','02']);
  
  
  unless ($opts{p}) {
    if ($opts{h} == 1 ) {
      open (IN, "<", $opts{g});
    my $out = 'trimmed';
    open (OUT,">", $out);
    foreach (<IN>) {
      chomp (my @line = split /\s+/, $_);
      my $add = 0;
      my $site = 0;
      my @new;
      foreach my $m (@line[2..$#line]) {
	if ($m eq '2' || $m eq '1') {
	  $add++; $site++; 
	}
	if ($m eq '0') {
	  $site++;
	} 
	if ($m eq '-1') {
	  $site++;
	}
	my $gene = $geno_hash{$m}[0] . $geno_hash{$m}[1];
	push (@new,  $gene);
      }
      if ($add > 0) {	
	  print OUT join ("\t", @new),"\n"; 		
      }
    }
    close IN;
    close OUT;
    open (IN2,"<", $out);
    my $add;
    while (<IN2>) {
    $add++;
    }
      close IN2;
         
    #trimmed ($opts{g},'trimmed' ,$opts{n}, \%geno_hash);
    transpose ('trimmed', $opts{n}, $add, 'transposed'); #transpose the matrix;
    genepop ('transposed', $opts{s}, $opts{o});
  }
    if  ($opts{h} == 0 ) {
    open (IN, "<", $opts{g}); 
    my %hash;
    my $size = $opts{n};
    open (OUT, ">", "selected");  
    
    
    foreach (<IN>) {
      chomp (my @line = split /\s/, $_);
      my $add = 0;
      my $site = 0;
      foreach my $m (@line[2..$#line]) {
	if ($m eq '2' || $m eq '1') {
	 $add++; $site++; 	 
       }
       if ($m eq '0') {
	 $site++;
       } 
       if ($m eq '-1') {
	 $site++;
       }
       if ($add > 0 && $site == $size) {
	 $hash{$line[0]}{$line[1]} = join ("\t",@line[2..$#line] ); 	
	 
       }
     }
    } 
    close IN;
    
    foreach (sort {$a cmp $b} keys %hash) { 
      my @array = ();
      foreach my $pos (keys %{$hash{$_}}){
	push (@array, $pos);
       }
      my $randomelement = $array[rand @array];
      print OUT $_, "\t", $randomelement, "\t", join("\t",$hash{$_}{$randomelement}), "\n";
    } 
    close OUT;
    
    
    open (IN2, "<", "selected");
    my $n = 0;
    foreach (<IN2>) {
      chomp(my @line = split /\t/, $_);
      $n++;   
    }
    close IN2;
    print "The number of selected sites now is: ", $n, "\n"; 
    trimmed ('selected','trimmed' ,$opts{n}, \%geno_hash);
    system("rm selected");
    transpose ('trimmed', $opts{n}, $n, 'transposed'); #transpose the matrix;
    genepop ('transposed', $n, $opts{o});
  }
   
    sub genepop {
      my ($in, $sites, $out) = @_;
      open (IN2, "<", $in);
      open (OPTo, '>', $out);
      my $count = 1;
      print OPTo "Man, do we have to have this line?", "\n";
      for ($count = 1; $count <= $sites; $count++) {
	if  ($count == 1) {
	  print OPTo "\t", "Loc". $count . "," ;	
	}
	elsif ($count < $sites && $count > 1) {
	  print OPTo " ", "Loc". $count . "," ;
	}
	else {
	  print OPTo " ", "Loc". $count;
	  
	}
      }
      print OPTo "\n";
      print OPTo "Pop","\n";
      open (IN2, '<', 'transposed');
      foreach (<IN2>) {
	chomp (my @d = split /\s+/, $_);
	print OPTo 'Ind,', " ", join (" ",@d[0..$#d]), "\n";
      }
      unlink ($in); 
      close OPTo;
      close IN2;
    }
  }
  
  
  if ($opts{p}) {
    jasonBraggG ($opts{g}, $opts{n}, 'out.JB.original',$opts{o}, \%geno_hash, $opts{s});
  }
  
  sub jasonBraggG {
    my ($file, $size, $out, $final, $geno_hash, $snps) = @_;
    my %geno_hash = %{$geno_hash};
    my %hash;
    open (IN, '<', $file);
    open (OUT, '>', $out);
    foreach (<IN>) {
      my @line = split /\s/, $_;
      my $add = 0;
      my $site = 0;
      foreach my $m (@line[2..$#line]) {
       if ($m eq '2' || $m eq '1') {
	 $add++; $site++; 	 
       }
       if ($m eq '0') {
	 $site++;
       } 
       if ($add >= 2 ) { ## && $site == $size removed
	 $hash{$line[0]}{$line[1]} = join ("\t",@line[2..$#line] ); 	

       }
     }
    } 
    close IN;

   foreach (sort {$a cmp $b} keys %hash) { 
     my @array = ();
     foreach my $pos (keys %{$hash{$_}}){
       push (@array, $pos);
     }
      my $randomelement = $array[rand @array];
      print OUT $_, "\t", $randomelement, "\t", join("\t",$hash{$_}{$randomelement}), "\n";
   }
    close OUT;
    
    trimmed ('out.JB.original','trimmed', $size, \%geno_hash);
    my $j=0;
    open (STUPID, "<", 'out.JB.original');
    foreach (<STUPID>) {
    $j++;
    }
    transpose('trimmed', $size, $j, 'transposed'); #transpose the matrix;
    genepop ('transposed', $j, $final);

  }
  
}


##########################
sub VCF2NEXUS {
  die(qq/
perl PopGenomics.pl VCF2NEXUS [options] 

options:

-v     FILE    a vcf file for all samples 
-k     INT     min number of individuals with less than -u INT coverage
-u     INT     minimum individual coverage threshold used in -k
-n     INT     sample size
-o     INT     outfile name prefix
-g     INT     minimal genotype Quality (phred-scaled confidence that the true genotype
               is the one provided in GT) [40]
-m     INT     1: no missing data allowed; 0: missing data allowed [1] 

Note: 
vcf is generated by SAMtools and BCFtools
to use -k and -u, -D must be used with satmools mpileup
It's recomended to use mpileup -I to ignore indels

It randomly selects one SNP for every contig. 

\n\n/) unless (@ARGV);
  
  my %opts = (v=>undef,k=>undef,u=>undef, n=>undef, o=>undef, m=>1, g=>40);
  getopts('v:k:u:n:o:m:g:', \%opts);
  
  
  my $vcf = $opts{v};
  my $ind = $opts{k};
  my $indcov =  $opts{u};
  my $missing = $opts{m};  
  my $sample = $opts{n};
  my $out =  $opts{o};
  my $gt = $opts{g};
  my %geno_hash = ('0/0' => '0',  '0/1' => '1' ,  '1/1' => '2');


  my ($hash, $indinfo) = parseVCF ($vcf,$ind,$indcov,$gt, \%geno_hash, $missing, $sample);
  
  my %hash = %{$hash};
  my @indinfo = @{$indinfo};
  
  my $selected = random (\%hash);
  
  nexus (\@indinfo, $selected, $out, $sample, $vcf);
  
  sub parseVCF {
    my ($vcf,$ind,$indcov,$gt,$geno_hash,$missing,$sample) = @_;
    my %hash;
    my %geno_hash = %{$geno_hash};
    my @ind; 
    open (VCF, "<", $vcf); 
    while (<VCF>) {
      my $covcount;
      my $add2 = 0;
      my $add1 = 0;
      my $add0 = 0;
      my $count = 0;
      
      chomp (my @t = split /\s+/, $_);
      
      next if $t[0] =~ m /^##/;
      
      
      if ($t[0] =~ m /^#CHROM/) {
	foreach (@t[9 .. $#t]) {
	  chomp (my $file = $_);
      	  my $lib = $1 if basename($file) =~ m/(\S+)_sorted.bam/;
	  push (@ind, $lib);
	} 
      }
      
      
      next if $t[0] =~ m /^#CHROM/;
      next if $t[4] =~ m /\./; #igonre non variable
      next if $t[4] =~ m /,/; #ignore non-diallelic
      next if $t[7] !~ m /^DP/; #ignore indels and other stuff
      next if $t[5] != 999; #ignore low quality variant calls
      
      my @genoinfo = @t[9 .. $#t];
      foreach (@genoinfo) {
	my @ind_info = split ":", $_;
	if ($ind_info[2] >= $indcov && $ind_info[2] >=$gt) { 
	  $hash{$t[0]}{$t[1]} .= $geno_hash{$ind_info[0]};
	  if ($geno_hash{$ind_info[0]} eq '2' ) {
	    $add2++;
	  }
	  if ($geno_hash{$ind_info[0]} eq '1') {
	    $add1++;
	  }
	  if ($geno_hash{$ind_info[0]} eq '0') {
	    $add0++; 
	  } 
	  $covcount++;
	}
	else {
	  $hash{$t[0]}{$t[1]} .= '?';     
	}
      }
      unless ($covcount) {
	delete $hash{$t[0]}{$t[1]};
      }
      
      if ($missing == 1 ) {
	if ($covcount) {
	  if ($covcount != $sample ) {	  
	    delete $hash{$t[0]}{$t[1]};
	  }
	  elsif  ($add1 + $add2 <= 1 || $add1 == $sample || $add2 == $sample || $covcount < $ind ||  $add0 == $sample ) {
	    delete $hash{$t[0]}{$t[1]};
	  } 
	}
      }
      
      if ($missing == 0 ) {
	if ($covcount) {
	  if  ($add1 + $add2 <= 1 || $add1 == $covcount || $add2 == $covcount || $covcount < $ind ||  $add0 == $covcount ) {
	    delete $hash{$t[0]}{$t[1]};
	  } 
	}
      }
    }
    close VCF;
    return (\%hash, \@ind);
  }
  
  
  sub random {
    my ($hash) =@_;
    my %hash =%{$hash};
    my $selected = "selected_one_SNP_per_Contig.txt";
    open (OUT, ">", $selected);
    my @final;
    foreach my $id (sort {$a cmp $b} keys %hash) {    
      my @array = (); 
      foreach my $pos (sort {$a <=> $b} keys %{$hash{$id}}){
	push (@array, $pos);
      } 
      my $randomelement = $array[rand @array];    
      print OUT $id, "\t", $randomelement, "\t", join("\t",$hash{$id}{$randomelement}), "\n" if ($randomelement);  
    } 
    close OUT;
    return $selected;
  }
  
  
  sub nexus {
    my ($indinfo, $selected, $final, $sample, $vcf) = @_;
    my @ind = @{$indinfo};
    
    open (IN, "<", $selected);
    open (OUT, ">", "trimmed");
    my $n =0;
    while (<IN>) {
      
      chomp(my @line = split /\s+/, $_);
      print OUT (join "\t", @line[2..$#line]), "\n";
      $n++;   
    }
    close IN; 
    close OUT;  
    print "The number of selected sites now is: ", $n, "\n";
    
    my $out = 'transposed';
    open (OUT1, '>', $out);
    
    for (my $i = 1; $i <= $sample; $i++) {
      my $count = $n;
      open (IN1, '<', 'trimmed');
      foreach (<IN1>) {
	chomp();	  
	if ($count > 1) {
	  my @line = split //, $_;
	  print OUT1 $line[$i-1], "\t";
	  $count--;
	}
	elsif ($count == 1) {
	  my @line = split //, $_;
	  print OUT1 $line[$i-1], "\n";
	}
	else {
	  last;
	}
      }
    }
    close IN1;
    close OUT1;
    
    open (IN, "<", 'transposed');
    my $results =  dirname($vcf) . "/" . $final . ".nexus";
    print "results are save in ", $results, "\n";
    open (OUT, ">", $results);
    
    print OUT "#NEXUS", "\n\n";
    print OUT "Begin data;", "\n";
    print OUT "\tDimensions ntax=$sample nchar=$n;","\n";
    print OUT "\tFormat symbols=","\"012\""," missing=?;","\n";
    print OUT "\tMatrix","\n\n"; 
    my $a = 0;
    
    while (<IN>) {
      chomp (my @line = $_);
      my @d = split /\s+/, $line[0];
      print OUT $ind[$a], "\t", @d, "\n";
      $a++;
    }
    print OUT "\t", ";","\n";
    print OUT "End;", "\n";
    #system("rm $selected trimmed transposed");
  }
}




#############################
sub VCF2smartPCA {
  die(qq/
perl PopGenomics.pl VCF2smartPCA [options] 

options:

-v     FILE    a vcf file for all samples 
-k     INT     min number of individuals with less than -u INT coverage
-u     INT     minimum individual coverage threshold used in -k
-n     INT     sample size
-o     INT     outfile name prefix
-g     INT     minimal genotype Quality (phred-scaled confidence that the true genotype
               is the one provided in GT) [40]
-m     INT     1: no missing data allowed; 0: missing data allowed [1] 

Note: 
vcf is generated by SAMtools and BCFtools
to use -k and -u, -D must be used with satmools mpileup
It's recomended to use mpileup -I to ignore indels
It randomly selects one SNP for every contig. 

*Important*: you may need to modify the second and third columns in output file, "XXX.sample". 

\n\n/) unless (@ARGV);
  
  my %opts = (v=>undef,k=>undef,u=>undef, n=>undef, o=>undef, m=>1, g=>40);
  getopts('v:k:u:n:o:m:g:', \%opts);
  
  
  my $vcf = $opts{v};
  my $ind = $opts{k};
  my $indcov =  $opts{u};
  my $missing = $opts{m};  
  my $sample = $opts{n};
  my $out =  $opts{o};
  my $gt = $opts{g};
  my %geno_hash = ('0/0' => '0',  '0/1' => '1' ,  '1/1' => '2');

  my ($hash, $indinfo) = parseVCF ($vcf,$ind,$indcov,$gt, \%geno_hash, $missing, $sample);
  
  my %hash = %{$hash};
  my @indinfo = @{$indinfo};
  my $selected = random (\%hash);
  
  my $eigen =  dirname($vcf) . "/" . $out . ".eigen";  
  my $snp =  dirname($vcf) . "/" . $out . ".snp";

  open (IN,"<",$selected) ;
  open (OUT1, ">", $snp);
  open (OUT2, ">", $eigen);
  
  while (<IN>) {
    chomp (my @line = split/\s+/, $_);
    print OUT1 $line[0] . "pos". $line[1], "\t", "1", "\t","0.0","\t","1","\n";
    my $gene = $line[2];
    $gene =~ s/\?/9/g;
    print OUT2 $gene, "\n";
  }
  close IN;
  close OUT1;
  close OUT2;
  unlink ($selected);
  
  my $samplefile = dirname($vcf) . "/" . $out . ".sample";
  open (SAMPLE, ">", $samplefile);
  foreach (@indinfo) {
    print SAMPLE $_, "\t", "U", "\t", "label","\n";
  }
  close SAMPLE;
  
  my $par = dirname($vcf) . "/" . $out . ".par";
  open (PAR, ">", $par);
  print PAR "#### input files", "\n";
  print PAR "genotypename: $eigen","\n";
  print PAR "snpname: $snp", "\n";
  print PAR "indivname: $samplefile","\n";

  print PAR "#### output files", "\n";
  print PAR "snpweightoutname: $out",".snpeigs","\n";
  print PAR "evecoutname: $out", ".eigs", "\n";
  print PAR "evaloutname: $out",".eval", "\n";
  print PAR "phylipoutname: $out",".fst","\n";
	  
  print PAR "#### run parameters", "\n";
  print PAR "numoutevec: 20","\n";
  print PAR "numoutlieriter: 0", "\n";
  print PAR "outlieroutname: $out", ".out", "\n";
  print PAR "altnormstyle: NO","\n";
  print PAR "missingmode: NO","\n";
  print PAR "nsnpldregress: 0","\n";
  print PAR "noxdata: YES","\n";
  print PAR "nomalexhet: YES", "\n";

  close PAR;
  
  
}

##########################

sub VCF2structure {
  die(qq/
perl PopGenomics.pl VCF2structure [options] 

options:

-v     FILE    a vcf file for all samples 
-k     INT     min number of individuals with less than -u INT coverage
-u     INT     minimum individual coverage threshold used in -k
-n     INT     sample size
-o     INT     outfile name prefix
-g     INT     minimal genotype Quality (phred-scaled confidence that the true genotype
               is the one provided in GT) [40]
-h     FILE    Population information
-m     INT     1: no missing data allowed; 0: missing data allowed [1] 

Note: 
vcf is generated by SAMtools and BCFtools
to use -k and -u, -D must be used with satmools mpileup
It's recomended to use mpileup -I to ignore indels
It randomly selects one SNP for every contig. 

The -h option is necessary. The input file contain two columns 
sampleID popID
sampleID popID
......

\n\n/) unless (@ARGV);
  
  my %opts = (v=>undef,k=>undef,u=>undef, n=>undef, o=>undef, m=>1, g=>40,h=>undef);
  getopts('v:k:u:n:o:m:g:h:', \%opts);
  
  
  my $vcf = $opts{v};
  my $ind = $opts{k};
  my $indcov =  $opts{u};
  my $missing = $opts{m};  
  my $sample = $opts{n};
  my $out =  $opts{o};
  my $gt = $opts{g};
  

  my %genos = ('AA' => 0 , 'AC' => 1, 'CA'=>1, 'AG' => 2, 'GA' => 2,  'AT' => 3, 'TA'=>3, 'CC'=> 4, 'CG'=>5, 'GC'=>5, 'CT' => 6, 'TC' => 6, 'GG'=>7, 'GT'=>8, 'TG'=>8, 'TT'=>9, 'NN' => -9);
  # A = 1, C = 2, G = 3, T = 4
  my %genos2 = ('0' => ['1','1'], '1' => ['1','2'], '2' => ['1','3'], '3' => ['1','4'], '4'=>['2','2'], '5'=>['2','3'], '6' => ['2','4'], '7'=>['3','3'], '8'=>['3','4'], '9'=>['4','4'], '-9' => ['-9','-9'] );
  
  
  my ($hash, $indinfo) = parseVCF1 ($vcf,$ind,$indcov,$gt, $missing, $sample);
  my %hash = %{$hash};
  my @indinfo = @{$indinfo};
  my $selected = random (\%hash);
  
  open (IN2, "<", "selected");
  my $n = 0;
  foreach (<IN2>) {
    chomp(my @line = split /\t/, $_);
    $n++;   
  }
  close IN2;
  print "The number of selected sites now is: ", $n, "\n";
  
  

  my $out1 = 'cleaned';
  trim1($sample,$n,$selected,$out1,\%genos);

  my $out2= 'converted';
  transpose($out1, $sample , $n, $out2); #transpose the matrix;

  my $final = dirname($vcf) . "/" .$out . "_genotype.txt";
   convert($out2, $final, \%genos2, $opts{h}); #convert the transposed matrix to input for structure;

  sub parseVCF1 {
    my ($vcf,$ind,$indcov,$gt,$missing,$sample) = @_;
    my %hash;
    
    my @ind; 
    open (VCF, "<", $vcf); 
    while (<VCF>) {
      my $covcount;
      my $add2 = 0;
      my $add1 = 0;
      my $add0 = 0;
      my $count = 0;
      
      chomp (my @t = split /\s+/, $_);
      
      next if $t[0] =~ m /^##/;
      
      
      if ($t[0] =~ m /^#CHROM/) {
	foreach (@t[9 .. $#t]) {
	  chomp (my $file = $_);
      	  my $lib = $1 if basename($file) =~ m/(\S+)_sorted.bam/;
	  push (@ind, $lib);
	} 
      }
      
      
      next if $t[0] =~ m /^#CHROM/;
      next if $t[4] =~ m /\./; #igonre non variable
      next if $t[4] =~ m /,/; #ignore non-diallelic
      next if $t[7] !~ m /^DP/; #ignore indels and other stuff
      next if $t[5] != 999; #ignore low quality variant calls
      
      my $ref= $t[3];
      my $alt =$t[4];
      my %geno_hash = ('0/0' => $ref . $ref,  '0/1' => $ref . $alt ,  '1/1' => $alt . $alt); 
      
      
      
      my @genoinfo = @t[9 .. $#t];
      foreach (@genoinfo) {
	my @ind_info = split ":", $_;
	if ($ind_info[2] >= $indcov && $ind_info[2] >=$gt) { 
	  $hash{$t[0]}{$t[1]} .= $geno_hash{$ind_info[0]};
	  if ($geno_hash{$ind_info[0]} eq $alt . $alt ) {
	    $add2++;
	  }
	  if ($geno_hash{$ind_info[0]} eq $ref . $alt) {
	    $add1++;
	  }
	  if ($geno_hash{$ind_info[0]} eq $ref . $ref ) {
	    $add0++; 
	  } 
	  $covcount++;
	}
	else {
	  $hash{$t[0]}{$t[1]} .= 'NN';     
	}
      }
      unless ($covcount) {
	delete $hash{$t[0]}{$t[1]};
      }
      
      if ($missing == 1 ) {
	if ($covcount) {
	  if ($covcount != $sample ) {	  
	    delete $hash{$t[0]}{$t[1]};
	  }
	  elsif  ($add1 + $add2 <= 1 || $add1 == $sample || $add2 == $sample || $covcount < $ind ||  $add0 == $sample ) {
	    delete $hash{$t[0]}{$t[1]};
	  } 
	}
      }
      
      if ($missing == 0 ) {
	if ($covcount) {
	  if  ($add1 + $add2 <= 1 || $add1 == $covcount || $add2 == $covcount || $covcount < $ind ||  $add0 == $covcount ) {
	    delete $hash{$t[0]}{$t[1]};
	  } 
	}
      }
    }
    close VCF;
    return (\%hash, \@ind);
  }

 sub trim1{
    my ($sample, $sites, $file, $out, $genos) = @_;
    my %genos = %{$genos};
    open (GENOPROB, '<', $file); 
    open (OUT, '>', $out);
    foreach (<GENOPROB>) {
     
      my @geno = split /\s+/, $_; 
      my $d = $geno[2];
      for (my $i = 0; $i<length($d); $i=$i+2) {
	print OUT $genos{substr($d, $i, 2)}, "\t";
      }
      print OUT $genos{substr($d, $sample, 2)},"\n";
    }

    close GENOPROB;
    close OUT;
    unlink ($file);
  } 
}


########################

sub VCF2admixture {
  die(qq/
perl PopGenomics.pl VCF2admixture [options] 

options:

-v     FILE    a vcf file for all samples 
-k     INT     min number of individuals with less than -u INT coverage
-u     INT     minimum individual coverage threshold used in -k
-n     INT     sample size
-o     INT     outfile name prefix
-g     INT     minimal genotype Quality (phred-scaled confidence that the true genotype
               is the one provided in GT) [40]
-m     INT     1: no missing data allowed; 0: missing data allowed [1] 

Note: 
vcf is generated by SAMtools and BCFtools
to use -k and -u, -D must be used with satmools mpileup
It's recomended to use mpileup -I to ignore indels
It randomly selects one SNP for every contig. 

\n\n/) unless (@ARGV);
  
  my %opts = (v=>undef,k=>undef,u=>undef, n=>undef, o=>undef, m=>1, g=>40);
  getopts('v:k:u:n:o:m:g:', \%opts);
  
  
  my $vcf = $opts{v};
  my $ind = $opts{k};
  my $indcov =  $opts{u};
  my $missing = $opts{m};  
  my $sample = $opts{n};
  my $out =  $opts{o};
  my $gt = $opts{g};
  my %geno_hash = ('0/0' => '0',  '0/1' => '1' ,  '1/1' => '2');

  my ($hash, $indinfo) = parseVCF ($vcf,$ind,$indcov,$gt, \%geno_hash, $missing, $sample);
  
  my %hash = %{$hash};
  my @indinfo = @{$indinfo};
  my $selected = random (\%hash);
  
  my $eigen =  dirname($vcf) . "/" . $out . ".eigen";  
  open (IN, "<",$selected);
  open (OUT2, ">", $eigen);
  
  while (<IN>) {
    chomp (my @line = split/\s+/, $_);
    my $gene = $line[2];
    $gene =~ s/\?/9/g;
    print OUT2 $gene, "\n";
  }
  close IN;
  close OUT2;
  unlink ($selected);
  
}


######################
sub VCF2splittree {
  die(qq/
perl PopGenomics.pl VCF2admixture [options] 

options:

-v     FILE    a vcf file for all samples 
-k     INT     min number of individuals with less than -u INT coverage
-u     INT     minimum individual coverage threshold used in -k
-n     INT     sample size
-o     INT     outfile name prefix
-g     INT     minimal genotype Quality (phred-scaled confidence that the true genotype
               is the one provided in GT) [40]
-m     INT     1: no missing data allowed; 0: missing data allowed [1] 

Note: 
vcf is generated by SAMtools and BCFtools
to use -k and -u, -D must be used with satmools mpileup
It's recomended to use mpileup -I to ignore indels
It randomly selects one SNP for every contig. 

\n\n/) unless (@ARGV);
         
 
  my %opts = (v=>undef,k=>undef,u=>undef, n=>undef, o=>undef, m=>1, g=>40);
  getopts('v:k:u:n:o:m:g:', \%opts);
  
  
  my $vcf = $opts{v};
  my $ind = $opts{k};
  my $indcov =  $opts{u};
  my $missing = $opts{m};  
  my $sample = $opts{n};
  my $out =  $opts{o};
  my $gt = $opts{g};
  my %geno_hash = ('0/0' => '11',  '0/1' => '12' ,  '1/1' => '22');
  my ($hash, $indinfo) = parseVCF2 ($vcf,$ind,$indcov,$gt, \%geno_hash, $missing, $sample);
  my %hash = %{$hash};
  my @indinfo = @{$indinfo};
  my $selected = random (\%hash);
  
  open (IN2, "<", $selected);
  my $n = 0;
  foreach (<IN2>) {
    chomp(my @line = split /\t/, $_);
    $n++;   
  }
  close IN2;
  print "The number of selected sites now is: ", $n, "\n";
 
  
  
  my $out1 = 'trimmed';

  open (IN, "<", $selected);
  open (OUT, ">", $out1);
  
  while (<IN>) {
    chomp (my @line = split/\t/, $_);
    my $d = $line[2];
    for (my $i = 0; $i<length($d); $i=$i+2) {
      print OUT substr($d, $i, 2), "\t";
    }
    print OUT substr($d, $sample, 2),"\n";
  }
  
  
  close IN;
  close OUT;
  
  system("rm selected");
  transpose('trimmed', $sample, $n, 'transposed'); #transpose the matrix;
  adegenet('transposed', $n, $out);
  
  
  
  sub parseVCF2 {
    my ($vcf,$ind,$indcov,$gt,$geno_hash,$missing,$sample) = @_;
    my %hash;
    my %geno_hash = %{$geno_hash};
    my @ind; 
    open (VCF, "<", $vcf); 
    while (<VCF>) {
      my $covcount;
      my $add2 = 0;
      my $add1 = 0;
      my $add0 = 0;
      my $count = 0;
      
      chomp (my @t = split /\s+/, $_);
      
      next if $t[0] =~ m /^##/;
      
      
      if ($t[0] =~ m /^#CHROM/) {
	foreach (@t[9 .. $#t]) {
	  chomp (my $file = $_);
      	  my $lib = $1 if basename($file) =~ m/(\S+)_sorted.bam/;
	  push (@ind, $lib);
	} 
      }
      
      
      next if $t[0] =~ m /^#CHROM/;
      next if $t[4] =~ m /\./; #igonre non variable
      next if $t[4] =~ m /,/; #ignore non-diallelic
      next if $t[7] !~ m /^DP/; #ignore indels and other stuff
      next if $t[5] != 999; #ignore low quality variant calls
      
      my @genoinfo = @t[9 .. $#t];
      foreach (@genoinfo) {
	my @ind_info = split ":", $_;
	if ($ind_info[2] >= $indcov && $ind_info[2] >=$gt) { 
	  $hash{$t[0]}{$t[1]} .= $geno_hash{$ind_info[0]};
	  if ($geno_hash{$ind_info[0]} eq '22' ) {
	    $add2++;
	  }
	  if ($geno_hash{$ind_info[0]} eq '12') {
	    $add1++;
	  }
	  if ($geno_hash{$ind_info[0]} eq '11') {
	    $add0++; 
	  } 
	  $covcount++;
	}
	else {
	  $hash{$t[0]}{$t[1]} .= 'NA';     
	}
      }
      unless ($covcount) {
	delete $hash{$t[0]}{$t[1]};
      }
      
      if ($missing == 1 ) {
	if ($covcount) {
	  if ($covcount != $sample ) {	  
	    delete $hash{$t[0]}{$t[1]};
	  }
	  elsif  ($add1 + $add2 <= 1 || $add1 == $sample || $add2 == $sample || $covcount < $ind ||  $add0 == $sample ) {
	    delete $hash{$t[0]}{$t[1]};
	  } 
	}
      }
      
      if ($missing == 0 ) {
	if ($covcount) {
	  if  ($add1 + $add2 <= 1 || $add1 == $covcount || $add2 == $covcount || $covcount < $ind ||  $add0 == $covcount ) {
	    delete $hash{$t[0]}{$t[1]};
	  } 
	}
      }
    }
    close VCF;
    return (\%hash, \@ind);
  }
  
}  
  
  


#############################


sub VCF2SPA {
  die(qq/
Usage PopGenomics.pl VCF2SPA [options]

options:

-v     FILE    a vcf file for all samples 
-k     INT     min number of individuals with less than -u INT coverage
-u     INT     minimum individual coverage threshold used in -k
-n     INT     sample size
-o     INT     outfile name prefix
-g     INT     minimal genotype Quality (phred-scaled confidence that the true genotype
               is the one provided in GT) [40]
-m     INT     1: no missing data allowed; 0: missing data allowed [1] 

Note: 
vcf is generated by SAMtools and BCFtools
to use -k and -u, -D must be used with satmools mpileup
It's recomended to use mpileup -I to ignore indels
It randomly selects one SNP for every contig. 

\n\n/) unless (@ARGV);
  my %opts = (v=>undef,k=>undef,u=>undef, n=>undef, o=>undef, m=>1, g=>40);
  getopts('v:k:u:n:o:m:g:', \%opts);
  
  
  my $vcf = $opts{v};
  my $ind = $opts{k};
  my $indcov =  $opts{u};
  my $missing = $opts{m};  
  my $sample = $opts{n};
  my $out =  $opts{o};
  my $gt = $opts{g};
  my %geno_hash = ('0/0' => '0',  '0/1' => '1' ,  '1/1' => '2');

  my ($hash, $indinfo) = parseVCF ($vcf,$ind,$indcov,$gt, \%geno_hash, $missing, $sample);
  
  my %hash = %{$hash};
  my @indinfo = @{$indinfo};
  my $selected = random (\%hash);
  
  my $before = dirname($vcf). "/". $opts{o} . "_before";
  open (IN,"<",$selected);
  open (OUT, ">", $before);
  my $n = 0;
  while (<IN>) {
    $n++;
    chomp (my @line = split/\t/, $_);
    my $d = $line[2];
    for (my $i = 0; $i<length($d); $i++) {
      print OUT substr($d, $i, 1), "\t";
    }
    print OUT substr($d, $sample, 1),"\n";
  }
  close IN;
  close OUT;
  
  #system ("rm $selected");
  print "The number of selected sites now is: ", $n, "\n";
  my $out2 = dirname($vcf). "/". $out . "_SPA.geno";
  transpose($before, $sample, $n , $out2);
  
}
  

######################################

sub BAYENV {
  die(qq/
Usage PopGenomics.pl BAYENV [options]

Options: -g FILE Raw genotype probability generated using ANGSD "-doGeno 2" (e.g. Contig29 294 0 1 2 -1 -1 2 1....)
         -o FILE Outfile perfix
         -p      Randomly selects one snp per contig, kick off non-varibale sites
         -n INT  Sample size (need -p)
         -z FILE population file
         -w INT  Number of populations
         -s INT  Number of sites

Note: currently, singletons and doubletons are removed!

\n/) if (!@ARGV);
  
  
  my %opts = (g=>undef,o=>undef, n=>undef,s=>undef,z=>undef,w=>undef);
  getopts('z:g:o:w:n:s:p', \%opts);
  
  my %pop;
  open (POP, "<", $opts{z});
  my $d = 1;
  foreach (<POP>) {
    chomp  (my @line = split /\s+/, $_);   
    $pop{$d} = $line[1];
    $d++;    
  }
  
  close POP;   
  
  if ($opts{p}) {
    my $new = unique ($opts{g}, $opts{n});
    my $final = bayen($new, \%pop, $opts{w}, $opts{o});
    unlink ($new);
    #system ("gzip $final");
  }
  unless ($opts{p}) {
    my $trim = 'trimmed'; 
    my $id = 'SNP_id.txt';
    open (IN, "<",$opts{g});
    open (OUT, ">", $trim);
    open (ID, ">", $id);
    my %hash;
    foreach (<IN>) {
      chomp (my @line = split /\s+/, $_);
      my $add = 0;
      my $site = 0;
      my $missing = 0;
      my $rare = 0;
      foreach my $m (@line[2..$#line]) {
	if ($m eq '2' ) {
	  $add++; $site++; $rare += 2;
	  }
	if ($m eq '1') {
	  $add++; $site++; $rare++;	 
	}
	if ($m eq '0') {
	  $site++;
	} 
	if ($m eq '-1') {
	  $site++; $missing++;
	}
      }
      if ($add > 0 && ($missing/$site <= 0.1) && $rare > 2 && (2 * $site - $rare) > 2) {
	print OUT $_; 
	print ID $line[0], "\t", $line[1], "\n";
       }
    } 
    close ID;
    close IN; close OUT;
    my $final = bayen($trim, \%pop, $opts{w}, $opts{o});
    #system ("gzip $final");
  }
  
  
  
  sub bayen {
    my ($geno,$pop, $popnum, $prefix) = @_;
    my %pop = %{$pop};
    my %ind;
    open (IN, "<", $geno);
    my $s = 1;
    foreach (<IN>) {
      chomp(my @line = split /\t+/, $_);
      #print $line[0],"\t",$line[1],"\n";
      my $c = 1;
      foreach (@line[2 .. $#line]) {
	if ($_ !~ m/^$/) {
	  my $ref = 0;
	  my $alt = 0;
	  
	  if ($_ eq '0') {
	    $ref = $ref+2;
	  } 
	  if ($_ eq '1'){
	    $ref = $ref+1; $alt = $alt+1;
	  }
	  if ($_ eq '2'){
	    $alt = $alt+2;  
	  }
	  if ($_ eq '-1'){
	    $ref = $ref+0;
	    $alt = $alt+0;
	  }
	  
	  $ind{$c}{$s} = {'ref' => $ref,'alt' => $alt, 'pop'=> $pop{$c}};   
	  $c++;
	}
      } 
      $s++;
      #print $s, "\n";
    }
   
    my %pop_all;
    for (my $ID = 1; $ID<= $popnum; $ID++) { 
    foreach my $i (sort {$a <=> $b} keys (%ind)) {
      foreach my $j  (sort {$a <=> $b} keys %{$ind{$i}}){	
	if ($ind{$i}{$j}{'pop'} =~  /\b$ID\b/ ) {	  	  
	  $pop_all{$ID}{$j}{'ref'} += $ind{$i}{$j}{'ref'};
	  $pop_all{$ID}{$j}{'alt'} += $ind{$i}{$j}{'alt'};
	} 
	
	else {
	  last;
	}
      }
    }    
  } 
    my $out =  $prefix . "_bayen.snp";
    open (OUT, ">", $out);
    my $sites =$s-1;
    
 
    for (my $j = 1; $j <= $sites ; $j++) {
      for (my $i = 1; $i <= $popnum ; $i++) { 
	if ($i < $popnum ) {
	  print OUT  $pop_all{$i}{$j}{'ref'}, "\t";
	}
	elsif ($i = $popnum) {
	  print OUT  $pop_all{$i}{$j}{'ref'}, "\n";
	}
      }
      
      for (my $k = 1; $k <= $popnum ; $k++) { 
	if ($k < $popnum ) {
	  print OUT  $pop_all{$k}{$j}{'alt'}, "\t";
	}
	elsif ($k = $popnum) {
	  print OUT  $pop_all{$k}{$j}{'alt'}, "\n";
	}
      }

    }
    
    close OUT;
    unlink ($geno);
    #my $final =  $prefix . "_bayen.snp"; 
    #transposed ($out,  $sites, $popnum, $final);  
    #return ($final);
    
  } 

}
############################

sub POPFilter {
  die(qq/
Usage PopGenomics.pl POPFilter [options]

Options: -g FILE  Raw genotype probability generated using ANGSD "-doGeno 2" (e.g. Contig29 294 0 1 2 -1 -1 2 1....)
         -o FILE  SNP pruned-in file by plink
         -z FILE  population file (two columns 1st popid 2nd sample size). popid must numerical (1,2,3,4,5,6,7).
         -w INT   total sample size for all sub populations
         -p CHAR  prefix
         -i FLOAT percent missing data allowed per subpop?[0.2]; 
         -s FLOAT percent missing data allowed total[0.1];

\n/) if (!@ARGV);
  
  
  my %opts = (g=>undef,o=>undef, z=>undef,i=>0.2, s=>0.1,p=>undef, w=>undef);
  getopts('z:g:o:i:s:p:w:', \%opts);
  
  my $prunein = $opts{o};
  my $GENO = $opts{g};
  my $dir = dirname($GENO); 
  
  my $geno = $dir . "/" . $opts{p} . "_before_filtering.geno"; 
  my $pop = $opts{z};
  my $out = $dir . "/" . $opts{p} . '_final.geno';
  my $out2 = $dir . "/" . $opts{p} . '_failed_passing_filter.geno';;
  my $samples = $opts{w};
  
  
  open (P, "<", $prunein);
  my %prune;
  while (<P>) {
    chomp (my @line = split/\s+/,$_);
    $prune{$line[0]}{$line[1]}++;
  }
  close P;
  
  open (G, "<",$GENO);
  open (OUT,">",$geno);
  while (<G>) {
    chomp (my @line = split/\s+/,$_);
    if ($prune{$line[0]}{$line[1]}) {
      print OUT $_;
    }
  }
  close G;
  close OUT;
  
  
  open (IN, "<", $geno);
  open (POP, "<", $pop);
  open (OUT,">",$out);
  open (OUT2,">", $out2);
  
  my %pops;
  my $d;
  while (<POP>) {
    chomp (my @line =split /\s+/, $_);
    $pops{$line[0]} = $line[1];
    $d++;
    #print $line[0], "\t", $line[1], "\n";
  }
  close POP;
  
  while (<IN>) {
    chomp (my @line =split/\s+/, $_);
    my $chr = $line[0];
    my $pos = $line[1];
    my $start = 2;
    my $missing = 0;
    my $popid =1;
    my $a = 1;
    my $all = 0;
 
    for (my $i = 1; $i<= $d ; $i++) {
      foreach my $m (@line[$start..($pops{$popid}+$start-1)]) {
	$all++ if $m == -1;
	$missing++ if $m == -1;
      }
      if ($missing/$pops{$popid} > 0.2) {
	$a++ ;
      }
      $missing = 0;
      $start += $pops{$popid};
      $popid++;
    }

    if ($a == 1 && $all/$samples <= $opts{s} ) {
      print OUT $_;
    }
    unless ($a == 1 || $all/$samples <= $opts{s}  ) {
      print OUT2 $_;
    }
    
    
  }
  unlink ($geno);
  close IN;
  close OUT;
  close OUT2;
}
##############

sub NEXUS {
  die(qq/
perl PopGenomics.pl NEXUS [options] 

options:

-g     FILE    genotype file (by angsd -doGeno 2);
-n     INT     sample size
-o     INT     outfile name prefix
-s     INT     sample ID 
-t     CHAR    only keep informative sites? 1 = yes, 0 = no [1] 
-m     FLOAT   missing data allowed to keep a SNP [0.2]
-h     FLOAT   Maximum proportion of shared polymorphic sites in a locus. This option is used to detect potential paralogs, as a shared heterozygous site across many samples likely represents clustering of paralogs with a fixed difference rather than a true heterozygous site (PyRad: Deren Eaton) [0.2]

Note: 
It randomly selects one SNP for every contig. 

\n\n/) unless (@ARGV);
  
  my %opts = (g=>undef, n=>undef, o=>undef,s=>undef,h=>0.2, t=>1, m=>0.2);
  getopts('g:n:o:s:h:t:m:', \%opts);
  


my $file =  $opts{g};
my $sample =  $opts{s};
my $out =  $opts{o};
my $number =  $opts{n};
my $het = $opts{h};
my $keep = $opts{t};
my $missing = $opts{m};

open (IN, "<", $file);
  my %hash;
  my @ind;  
  while (<IN>) {
    chomp (my @line = split /\s+/,$_);
    my $geno =join('',@line[2 .. $#line]);
    $geno =~ s/-1/?/g;
    my @miss = ($geno =~ m/\?/g);
    my @het = ($geno =~ m/1/g);
    my @homR =  ($geno =~ m/0/g);
    my @homA =  ($geno =~ m/2/g);
    if (scalar(@homA) + scalar(@het) > $keep && scalar(@homR) > 1 ) {
      if (scalar(@het)/$number < $het) {
	if (scalar(@miss)/$number <= $missing) {
	  $hash{$line[0]}{$line[1]} = $geno;
	}
      }
    }
  }
  close IN;
  my $selected = 'sites_ALL_pass_filtered.keep';
  open (OUT, ">", $selected);
  foreach my $id (sort {$a cmp $b} keys %hash) {
    foreach my $pos (sort {$a cmp $b} keys %{$hash{$id}}) {
      print OUT $id, "\t", $pos, "\t", $hash{$id}{$pos}, "\n";
    }
  }
  close OUT;
  
  
  
  open (ID, "<", $sample);
  
  while (<ID>) {
    chomp (my $line = $_);
    push (@ind, $line);
  }
  close ID;
  
  my $selected1 = random (\%hash);
  nexus (\@ind, $selected1, $out, $number,$file);
}

###################

sub CONTIG {
  die(qq/
PopGenomics.pl CONTIG [options] 

options:

-g  FILE  genotype file generated by angsd -doGeno 4 (-SNP_pval 1e-6 -postCutoff 0.95)
-f  FILE  reference used for alignment
-s  FILE  SNPs that pass all filters (usually generated by PopgenTools NEXUS)
-a  FILE  a file contain all sample ID

\n\n/) unless (@ARGV);
  
  
  my %opts = (g=>undef, f=>undef,s=>undef,a=>undef);
  getopts('g:f:s:a:', \%opts);
  
  my $geno = $opts{g};
  my $reference = $opts{f};
  my $snp = $opts{s};
  my $sample = $opts{a};


  my %seq;
  open (FILE, "<", $reference);
  while (<FILE>) {
    chomp (my $line = $_);
    if ($line =~ /^>(\S+)/) {
      my $id = $1;
      chomp (my $seq = <FILE>);
      my $len = length ($seq);
      $seq{$id}{'seq'} = $seq;
      $seq{$id}{'len'} = $len;
    } 
  }
  close FILE;
  
  
  my %snp;
  open (SNP, "<", $snp);
  while (<SNP>) {
    chomp (my @line = split /\s+/, $_);
    $snp{$line[0]}{$line[1]}++;
  }
  close SNP;
  
  my %sam;
  my $size;

  my $d = 1;
  open (SAMPLE, "<", $sample);
  while (<SAMPLE>) {
    chomp (my $line = $_);
    $sam{$d} = $line;
    $size++;
    $d++;
  }
  close SAMPLE;
  
  
  my %genos = ('AA' => 'A' , 'AC' => 'M', 'CA'=>'M', 'AG' => 'R', 'GA' => 'R',  'AT' => 'W', 'TA'=>'W', 'CC'=> 'C', 'CG'=>'S', 'GC'=>'S', 'CT' => 'Y', 'TC' => 'Y', 'GG'=>'G', 'GT'=>'K', 'TG'=>'K', 'TT'=>'T', 'NN' => 'N');
  
  
  my $site;
  open (GENO, "<", $geno);  
  while (<GENO>) {
    $site++;
  }
  close GENO;
  
  
  my %final;
  
  for (my $i = 1; $i <= $size; $i++) {

    my $s;
    my $contig;
    my $pos;
    
    open (GENO, "<", $geno);
    foreach (<GENO>) {
      chomp(my @line = split /\s+/, $_);
      $contig = $line[0];
      $pos = $line[1];
      if ($snp{$contig}) {
	if ($snp{$contig}{$pos}) {
	  unless ($final{$sam{$i}}{$contig}) {
	    $s = $seq{$contig}{'seq'};
	    substr($s, $pos-1, 1) = $genos{$line[$i+1]};
	    $final{$sam{$i}}{$contig} = $s;
	  }
	  else {
	    substr($s, $pos-1, 1) = $genos{$line[$i+1]};
	    $final{$sam{$i}}{$contig} = $s;
	  }
	}
	else {
	  unless ($final{$sam{$i}}{$contig}) {
	    $s = $seq{$contig}{'seq'};
	    substr($s, $pos-1, 1) = 'N';
	    $final{$sam{$i}}{$contig} = $s;
	  }
	  else {
	    substr($s, $pos-1, 1) = 'N';
	    $final{$sam{$i}}{$contig} = $s;
	  }
	}
      }
    }
    close GENO;	
  }
    
  my $out = 'final_alignment.phylip';
  my $par = 'partition.txt';
  my $all;
  open (OUT, ">", $out);
  open (PAR, ">", $par);
  my $c =0;
  my $locus =1;
   foreach my $sample (sort {$a cmp $b} keys %final) {
    foreach my $contig (sort {$a cmp $b} keys %{$final{$sample}}) {
      print PAR "locus", $locus, " = ";
      print PAR $c+1, "-", $c+length ($final{$sample}{$contig}), "\n";
      $locus++;
      $c += length ($final{$sample}{$contig});
      $all += length ($final{$sample}{$contig});
    }
    last;
  }
  close PAR;
  print "the total length of the alignment is: ", $all, "bp!", "\n"; 
  print OUT $size, " ", $all,"\n";
  foreach my $sample (sort {$a cmp $b} keys %final) {
    my $total;
    print OUT $sample, " ";
    #my $name_space = length ($sample) + 1;
    foreach my $contig (sort {$a cmp $b} keys %{$final{$sample}}) {
      $total .= $final{$sample}{$contig};
    } 
    print OUT " ", $total, "\n";
    #my $l = length ($total);
    #l=200 i =181, 
    #foreach (my $i = 1; $i <= $l; $i = $i + 100) {
     # if ($l-$i >=100) {
#	print OUT " " x $name_space, substr ($total,$i-1,100), "\n";
 #     }
  #     if ($l-$i < 100) {
#	#print OUT substr ($total,$i-1,60), "\n";
#	print OUT " " x $name_space, substr ($total,$i-1,$l-$i+1), "\n";
 #     } 
  #  }
  }
  close OUT;
  
}

################################


sub PHASE {
  die(qq/
PopGenomics.pl PHASE [options] 

options:

-g  FILE    genotype file (each line is one individual, each column is one site)
-n  INT     number of samples 
-o  CHAR    outname prefix

Note: Assume PHASE is in path
Note: Only work for SNP data

\n\n/) unless (@ARGV);
  
  
  my %opts = (g=>undef, n=>undef, o=>undef);
  getopts('g:n:o:', \%opts);
  
  my %genos = ('-1' => ['?','?'], '0' => ['0','0'], '1' => ['0','1'], '2' => ['1','1']);
  
  my $geno = $opts{g};
  my $sample = $opts{n};
  my $out = $opts{o};
  my $snp = 'snp_id.txt';
  my $dir = dirname($geno) . "/";
  my $newgeno = 'trimmed_geno.txt';
  
  open (IN, "<", $geno);
  open (ID, ">",$snp);
  open (OUT, ">", $newgeno);
  
  foreach (<IN>) {
    chomp (my @line = split /\s+/, $_);
    my $add = 0;
    my $site = 0;
    my $missing = 0;
    foreach my $m (@line[2..$#line]) {
      if ($m eq '2')  { ### if you want to add MAF filter do it here!
	$add++; $site++; 	 
      }
      if ($m eq '1') {
	$add++; $site++; 
      }
      if ($m eq '0') {
	$site++;
      } 
      if ($m eq '-1') {
	$site++; $missing++;
      }
    }
    if ($add > 0  ) { #($missing/$site <= 0.1)
      print OUT join "\t", @line[2..$#line] ,"\n"; 
      print ID $line[0], "\t", $line[1], "\n";
    }
  } 
  close ID;
  close OUT;
  
  open (IN2,"<", $newgeno);
  my $add;
  while (<IN2>) {
    $add++;
  }
  close IN2;
  my $out2 = "input.geno";
  transpose($newgeno, $sample, $add, $out2); 
  
  
  my %snp;
  my %sites;
  my %ac;
  open (SNP, "<", $snp);
  my $d = 1;
  while (<SNP>) {
    chomp (my @line = split /\s+/, $_);
    if ($d == $line[0]) {
      $snp{$line[0]}{$line[1]}++;
      $sites{$line[0]}++;
    }
    else {
      $d++;
      $snp{$line[0]}{$line[1]}++;
      $sites{$line[0]}++;
      
    }
  }
  close SNP;
  
  my $start;
  my $end;
  for (my $i=1; $i <= $d; $i++) {
    my $input = $dir . 'chromosome' . $i . '.inp';
    my $ldhat = $dir . 'ldhat' . $i . '.ldhat_input';
    open (OUT, ">", $input);
    open (LD, ">", $ldhat);
  
    print OUT $sample, "\n", $sites{$i}, "\n", "P ";
    print LD $sample," ",$sites{$i}, " 2","\n";
    #chromosome1 200
    #chromosome2 100
    #chromosome3 50
    
    
    $end +=  $sites{$i};
    $start = $end - $sites{$i} + 1;
 
    
    my $add = 0;
    foreach my $chr (sort {$a <=>$b } keys %snp) {
      foreach my $pos (sort {$a <=>$b } keys %{$snp{$chr}}){
	if ($chr  == $i) {
	  $add++;
	  if ($add < $sites{$i}) {
	    print OUT $pos, " ";	
	  }
	  if ($add  == $sites{$i}) {
	    print OUT $pos, "\n";	
	  }
	}
      }
    }
    
    for (my $j=1; $j <=$add; $j++) {
      print OUT "S";
    }
    print OUT "\n";
   
    open (GENO1, "<", $out2);
    my $sid = 1;
    while (<GENO1>) {
      chomp (my @line = split /\s+/, $_);       
      print LD "#", $sid, "\n";     
      my @site = @line[$start-1 .. $end-1];
      my @ld = @site;
      print LD ">sample", $sid, "\n";
       foreach (@ld) {
	 chomp (my $line = $_);
	 if ($line != -1) {
	   print LD $line;
	 }
	  if ($line == -1) {
	   print LD "?";
	 }	 
      }
      print LD "\n";
      
      foreach (@site) {
	chomp (my $item = $_);
	print OUT $genos{$item}[0];
      }
      print OUT "\n";
      
      @site = @line[$start-1 .. $end-1];
      
      foreach (@site) {
	chomp (my $item = $_);
	print OUT $genos{$item}[1];
      }
      print OUT "\n";
      $sid++;
    }
    close OUT; close GENO1;
  }
}


###########################
  
  
  
sub Dxy {
  die(qq/
PopGenomics.pl Dxy [options] 

options:

-1  FILE  genotype file generated by angsd -doGeno 3 
-2  FILE  genotype file generated by angsd -doGeno 3
-o  FILE  outfile name

\n\n/) unless (@ARGV);
  
  
  my %opts = (1=>undef, 2=>undef, o=>undef);
  getopts('1:2:o:', \%opts);
  

  my $pop1 = $opts{1};
  my $pop2 = $opts{2};
  my $out = $opts{o};

  my %p1;
  my %p2;
  

  
  open (G1, "<", $pop1);
  open (G2, "<", $pop2);
  while (<G1>) {
    chomp (my @line = split /\s+/, $_);
    my $contig = $line[0];
    my $pos = $line[1];
    push @{$p1{$contig}{$pos}},  @line[2..$#line];
    chomp (my $l = <G2>);
    my @a = split /\s+/, $l;
    push @{$p2{$a[0]}{$a[1]}},  @a[2..$#a];
    
  }
  close G1; close G2;
  
  my %Dxy;
  my $all;
  my $sites;
 
  foreach my $id (sort {$a cmp $b} keys %p1) {
    foreach my $pos (sort {$a cmp $b} keys %{$p1{$id}}) {
      my $n;
      my $count;
      foreach  (@{$p1{$id}{$pos}}) {
	my $geno1 = $_; 
	
	next if $geno1 == -9;
	foreach (@{$p2{$id}{$pos}}) {
	  my $geno2 = $_;
	  next if $geno2 == -9;
	  if ($geno1 == $geno2) {
	    $count++;
	    if ($geno1 != 1) {
	      $n += 0;
	    }
	    if ($geno1 == 1) {
	      $n += 1;
	    }
	  } 
	  if ($geno1 != $geno2) {
	    $count++;
	    if (abs($geno1-$geno2) == 2) {
	      $n += 2;
	    }
	    if (abs($geno1-$geno2) == 1) {
	      $n += 1;
	    }
	  }
	} 
      }  
      $all += $n/$count if ($count > 0 ) ;
      $sites ++  if ($count > 0 ) ;
      $Dxy{$id}{'data'} += $n/$count if ($count > 0 ) ;
      $Dxy{$id}{'site'} ++ if ($count > 0 ) ;
    }    
  }
  print sprintf("%.4f", $all/$sites), "\n";
  open (OUT, ">",$out );
  foreach my $id (sort {$a cmp $b} keys %Dxy) {
    print OUT $id, "\t", sprintf("%.4f",$Dxy{$id}{'data'}/$Dxy{$id}{'site'}), "\n";
  }


}


################################################


sub raxml {

 die(qq/
PopGenomics.pl raxml [options] 

Options: -f    folder containning all bams
         -o    outdir
         -r    reference
         -d    minimal depth [5]
         -a    sample ID file (one column)


\n/) if (!@ARGV);
  
my %opts = (f=>undef, r=>undef,d=>5,o=>undef,a=>undef);
getopts('f:r:d:o:a:', \%opts);

my $dir;
if ($opts{f} =~m/\/$/) {
  $dir = $opts{f};
}
else {
  $dir = $opts{f} . "/";
}

my $outdir;
if ($opts{o} =~m/\/$/) {
  $outdir = $opts{o};
}
else {
  $outdir = $opts{o} . "/";
}



my $sample = $opts{a};
my $ref = $opts{r};
my $depth = $opts{d};

my %sam;
my $size;
my $d = 1;
open (SAMPLE, "<", $sample);
while (<SAMPLE>) {
  chomp (my $line = $_);
  $sam{$d} = $line;
  $size++;
  $d++;
}
close SAMPLE;


my @file = <$dir*.bam>;
my %newfix;
foreach (@file) {
  my $file = $_;
  # JMSR003_indexing10_sorted.bam
  my $lib = $1 if basename ($file) =~ m /(\S+)_sorted.bam/;
  my $fa = $outdir . $lib . ".fasta";
  
  system ("samtools mpileup -B -uf $ref $file | bcftools view -cg -  | vcfutils.pl vcf2fq -d $depth  >  $fa ");
  
  open (REF, "<", $ref);
  my %ref;
  while (<REF>) {
    chomp (my $line = $_);
    if ($line  =~ m /^>(\S+)/ ) {
      chomp ($ref{$1} = <REF>); 
    } 
  }
  close REF;
  
  open (FIX, "<", $fa);
  my %fix;
  my $id;
  while (<FIX>) {
    chomp (my $line = $_);
    if ($line  =~ m /^>(\S+)/ ) {
      $id = $1; 
    } 
    else {
      $line =~ s/[a|c|g|t|n|]/N/g ;
      $line = uc ($line); # s/[a|c|g|t|n|]/N/g ;y|s|k|r|w|m|Y|S|R|K|W|M
      $fix{$id} .= $line;
    }
  }
  close FIX;
  
  
  my $out = $outdir . $lib . ".fasta";
  open (OUT , ">", $out);
  
  foreach my $line (sort {$a cmp $b} keys %ref) {
    if ($fix{$line}) {
      if ((length ($fix{$line})) < (length ($ref{$line}))) {   
	my $diff = (length ($ref{$line})) - (length ($fix{$line})); 
	my $N = 'N' x $diff;
	my $newseq =  $fix{$line}. $N; 
	$newfix{$lib}{$line} = $newseq; 
	print OUT $line , "\n";
	print OUT $newseq, "\n";
      }
      else {
	$newfix{$lib}{$line} = $fix{$line};
	print OUT $line , "\n";
	print OUT $fix{$line}, "\n";
      }
    }
    else  {
      $newfix{$lib}{$line} = 'N' x length($ref{$line});
      print OUT $line , "\n";
      print OUT 'N' x length($ref{$line}), "\n";
    }      
  }  
}

my $out = 'final_alignment.phylip';
my $par = 'partition.txt';
my $all;
open (OUT, ">", $out);
open (PAR, ">", $par);
my $c = 0;
my $locus =1;
foreach my $sample (sort {$a cmp $b} keys %newfix) {
  foreach my $contig (sort {$a cmp $b} keys %{$newfix{$sample}}) {
    print PAR "locus", $locus, " = ";
    print PAR $c+1, "-", $c+length ($newfix{$sample}{$contig}), "\n";
    $locus++;
    $c += length ($newfix{$sample}{$contig});
    $all += length ($newfix{$sample}{$contig});
  }
  last;
}
close PAR;
print "the total length of the alignment is: ", $all, "bp!", "\n"; 
print OUT $size, " ", $all,"\n";
foreach my $sample (sort {$a cmp $b} keys %newfix) {
  my $total;
  print OUT $sample, " ";
  #my $name_space = length ($sample) + 1;
  foreach my $contig (sort {$a cmp $b} keys %{$newfix{$sample}}) {
    $total .= $newfix{$sample}{$contig};
  } 
  print OUT " ", $total, "\n";
  }
close OUT;

}








